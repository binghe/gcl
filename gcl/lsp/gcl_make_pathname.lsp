(in-package :si)

(defun directory-list-check (l)
  (when (listp l)
    (when (member (car l) '(:absolute :relative))
      (mapl (lambda (x &aux (c (car x))(d (cadr x)))
	      (when (and (member d '(:up :back)) (member c '(:absolute :wild-inferiors)))
		(return-from directory-list-check nil))) l))))
    
(defun canonicalize-pathname-directory (l)
  (cond ((eq l :wild) (canonicalize-pathname-directory '(:absolute :wild-inferiors)))
	((stringp l) (canonicalize-pathname-directory (list :absolute l)))
	((mapl (lambda (x &aux (c (car x)))
		 (when (and (or (stringp c) (eq c :wild)) (eq (cadr x) :back))
		   (return-from canonicalize-pathname-directory
		     (canonicalize-pathname-directory (nconc (ldiff l x) (cddr x)))))) l))))

(defun process-case (x c)
  (cond ((eq c :local) x)
	((symbolp x) x)
	((listp x) (mapcar (lambda (x) (process-case x c)) x))
	((find-if 'upper-case-p x) (if (find-if 'lower-case-p x) x (string-downcase x)))
	((find-if 'lower-case-p x) (string-upcase x))
	(x)))

(defun sisym (&rest r)
  (declare (:dynamic-extent r))
  (intern (apply 'concatenate 'string (mapcar 'string r)) :si))

(defun make-pathname (&key (host nil hostp) (device nil devicep) (directory nil directoryp)
			   (name nil namep) (type nil typep) (version nil versionp)
			   defaults (case :local))
  (declare (optimize (safety 1)))
  (check-type host (or (member nil :unspecific) string))
  (check-type device (member nil :unspecific))
  (check-type directory (or (member nil :unspecific :wild) string list))
  (check-type name (or string (member nil :unspecific :wild)))
  (check-type type (or string (member nil :unspecific :wild)))
  (check-type version (or (integer 1) (member nil :unspecific :wild :newest)))
  (check-type defaults (or null pathname-designator))
  (check-type case (member :common :local))
  (macrolet ((m (k &aux (f (sisym "PATHNAME-" k)) (p (sisym k "P")))
		`(process-case (if ,p ,k ,(if (eq k 'host) `(,f (or def *default-pathname-defaults*)) `(when def (,f def)))) case)))
    (let* ((def (when defaults (pathname defaults)))
	   (h (m host))
	   (dev (m device))
	   (d (canonicalize-pathname-directory (m directory)))
	   (n (m name))
	   (typ (m type))
	   (v (m version))
	   (lp (logical-pathname-translations h))
	   (p (init-pathname h dev d n typ v (to-regexp1 (list h dev d n typ v) nil lp)))
	   (p (if lp (logical-pathname p) p)))
      (unless (eq d (directory-list-check d))
	(error 'file-error :pathname p :format-control "Bad directory list"))
      p)))

(macrolet ((m (k &aux (f (sisym "PATHNAME-" k)) (c (sisym "C-PATHNAME-" k)))
	      `(defun ,f (p &key (case :local) &aux (pn (pathname p)))
		 (declare (optimize (safety 1)))
		 (check-type p pathname-designator)
		 (process-case (,c pn) case))))
  (m host)
  (m device)
  (m directory)
  (m name)
  (m type)
  (m version)))


