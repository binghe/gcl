

@node Evaluation and Compilation, Types and Classes, Syntax, Top
@chapter Evaluation and Compilation

@menu
* Evaluation::			
* Compilation::			
* Declarations::		
* Lambda Lists::		
* Error Checking in Function Calls::  
* Traversal Rules and Side Effects::  
* Destructive Operations::	
* Evaluation and Compilation Dictionary::  
@end menu

@node Evaluation, Compilation, Evaluation and Compilation, Evaluation and Compilation
@section Evaluation

@c including concept-eval

@i{Execution} of @i{code} can be accomplished by a variety of means ranging
from direct interpretation of a @i{form} representing a @i{program}
to invocation of @i{compiled code} produced by a @i{compiler}.

@i{Evaluation}
@IGindex evaluation
 is the process by which a @i{program} is @i{executed} in @r{Common Lisp}.
The mechanism of @i{evaluation} is manifested
 both implicitly through the effect of the @i{Lisp read-eval-print loop},
 and  explicitly through the presence of the @i{functions} 
       @b{eval},
       @b{compile},
       @b{compile-file},
   and @b{load}.
Any of these facilities might share the same execution strategy, 
or each might use a different one.

The behavior of a @i{conforming program} processed by @b{eval}
and by @b{compile-file} might differ; see @ref{Semantic Constraints}.

@i{Evaluation} can be understood in terms of a model in which an
interpreter recursively traverses a @i{form} performing each
step of the computation as it goes.  
This model, which describes the semantics of @r{Common Lisp} @i{programs},
is described in @ref{The Evaluation Model}.

@menu
* Introduction to Environments::  
* The Evaluation Model::	
* Lambda Expressions::		
* Closures and Lexical Binding::  
* Shadowing::			
* Extent::			
* Return Values::		
@end menu

@node Introduction to Environments, The Evaluation Model, Evaluation, Evaluation
@subsection Introduction to Environments

A @i{binding}
@IGindex binding
 is an association between a @i{name} and
that which the name denotes.  @i{Bindings} are @i{established}
in a @i{lexical environment} or a @i{dynamic environment}
by particular @i{special operators}.

An @i{environment}
@IGindex environment
 is a set of @i{bindings} and other information
used during evaluation (@i{e.g.}, to associate meanings with names).

@i{Bindings} in an @i{environment} are partitioned into @i{namespaces}
@IGindex namespace
.
A single @i{name} can simultaneously have more than one
associated @i{binding} per @i{environment},
but can have only one associated @i{binding} per @i{namespace}.

@menu
* The Global Environment::	
* Dynamic Environments::	
* Lexical Environments::	
* The Null Lexical Environment::  
* Environment Objects::		
@end menu

@node The Global Environment, Dynamic Environments, Introduction to Environments, Introduction to Environments
@subsubsection The Global Environment

The @i{global environment}
@IGindex global environment
 is that part of an @i{environment}
that contains @i{bindings} with both @i{indefinite scope} 
and @i{indefinite extent}.
The @i{global environment} contains, among other things, the following:

@table @asis

@item @t{*}  
@i{bindings} of @i{dynamic variables} and @i{constant variables}.
@item @t{*}  
@i{bindings} of @i{functions}, @i{macros}, and @i{special operators}.
@item @t{*}  

 @i{bindings} of @i{compiler macros}.

@item @t{*}  
@i{bindings} of @i{type} and @i{class} @i{names}
@item @t{*}  
information about @i{proclamations}.
@end table

@node Dynamic Environments, Lexical Environments, The Global Environment, Introduction to Environments
@subsubsection Dynamic Environments

A @i{dynamic environment}
@IGindex dynamic environment
 for @i{evaluation} is that part of an
@i{environment} that contains @i{bindings} whose duration
is bounded by points of @i{establishment} and @i{disestablishment} 
within the execution of the @i{form} that
established the @i{binding}.
A @i{dynamic environment} contains, among other things, the following:

@table @asis

@item @t{*}  
@i{bindings} for @i{dynamic variables}.
@item @t{*}  
information about @i{active} @i{catch tags}.
@item @t{*}  
information about @i{exit points} established by @b{unwind-protect}.
@item @t{*}  
information about @i{active} @i{handlers} and @i{restarts}.
@end table

The @i{dynamic environment} that is active at any given point 
in the @i{execution} of a @i{program} is referred to by 
definite reference as ``the current @i{dynamic environment},''
or sometimes as just ``the @i{dynamic environment}.''

Within a given @i{namespace},
a @i{name} is said to be @i{bound}
in a @i{dynamic environment} if there is a @i{binding} 
associated with its @i{name} in the @i{dynamic environment} 
or, if not, there is a @i{binding} 
associated with its name in the @i{global environment}.

@node Lexical Environments, The Null Lexical Environment, Dynamic Environments, Introduction to Environments
@subsubsection Lexical Environments

A @i{lexical environment}
@IGindex lexical environment
 for @i{evaluation} at some position in a @i{program}
is that part of the @i{environment} that contains information having 
@i{lexical scope} within the @i{forms} containing that position.
A @i{lexical environment} contains, among other things, the following:

@table @asis

@item @t{*}  
@i{bindings} of @i{lexical variables} and @i{symbol macros}.
@item @t{*}  
@i{bindings} of @i{functions} and @i{macros}.
             (Implicit in this is information about those @i{compiler macros} 
	      that are locally disabled.)
@item @t{*}  
@i{bindings} of @i{block tags}.
@item @t{*}  
@i{bindings} of @i{go tags}.
@item @t{*}  
information about @i{declarations}.
@end table

The @i{lexical environment} that is active at any given position
in a @i{program} being semantically processed is referred to by
definite reference as ``the current @i{lexical environment},''
or sometimes as just ``the @i{lexical environment}.''  

Within a given @i{namespace},
a @i{name} is said to be @i{bound} in a @i{lexical environment}
if there is a @i{binding} 
associated with its @i{name}
in the @i{lexical environment} or, if not, there is a @i{binding} 
associated with its name in the @i{global environment}.

@node The Null Lexical Environment, Environment Objects, Lexical Environments, Introduction to Environments
@subsubsection The Null Lexical Environment

The @i{null lexical environment}
@IGindex null lexical environment
 is equivalent to the @i{global environment}.

Although in general the representation of an @i{environment} @i{object}
is @i{implementation-dependent}, @b{nil} can be used in any situation where an
@i{environment} @i{object} is called for in order to denote 
the @i{null lexical environment}.

@node Environment Objects,  , The Null Lexical Environment, Introduction to Environments
@subsubsection Environment Objects

Some @i{operators} make use of an @i{object}, 
called an @i{environment object}
@IGindex environment object
,
that represents the set of @i{lexical bindings} needed to perform
semantic analysis on a @i{form} in a given @i{lexical environment}.
The set of @i{bindings} in an @i{environment object}
may be a subset of the @i{bindings} that would be needed to actually 
perform an @i{evaluation}; for example, @i{values} associated with
@i{variable} @i{names} and @i{function names} in the corresponding
@i{lexical environment} might not be available in an @i{environment object}.

The @i{type} and nature of an @i{environment object} is @i{implementation-dependent}.
The @i{values} of @i{environment parameters} to @i{macro functions}
are examples of @i{environment objects}.

The @i{object} @b{nil} when used as an @i{environment object}
denotes the @i{null lexical environment};
see @ref{The Null Lexical Environment}.

@node The Evaluation Model, Lambda Expressions, Introduction to Environments, Evaluation
@subsection The Evaluation Model

A @r{Common Lisp} system evaluates @i{forms} with respect to lexical,
dynamic, and global @i{environments}.  The following sections
describe the components of the @r{Common Lisp} evaluation model.

@menu
* Form Evaluation::		
* Symbols as Forms::		
* Lexical Variables::		
* Dynamic Variables::		
* Constant Variables::		
* Symbols Naming Both Lexical and Dynamic Variables::  
* Conses as Forms::		
* Special Forms::		
* Macro Forms::			
* Function Forms::		
* Lambda Forms::		
* Self-Evaluating Objects::	
* Examples of Self-Evaluating Objects::	 
@end menu

@node Form Evaluation, Symbols as Forms, The Evaluation Model, The Evaluation Model
@subsubsection Form Evaluation

@i{Forms} fall into three categories:
@i{symbols}, @i{conses}, and @i{self-evaluating objects}.
The following sections explain these categories.

@node Symbols as Forms, Lexical Variables, Form Evaluation, The Evaluation Model
@subsubsection Symbols as Forms

If a @i{form} is a @i{symbol},
then it is either a @i{symbol macro} or a @i{variable}.

The @i{symbol} names a @i{symbol macro} 
if there is a @i{binding} of the @i{symbol} as a @i{symbol macro}
in the current @i{lexical environment} 

 (see @b{define-symbol-macro} and @b{symbol-macrolet}).

If the @i{symbol} is a @i{symbol macro},
its expansion function is obtained.
The expansion function is a function of two arguments, and is invoked
by calling the @i{macroexpand hook} with 
     the expansion function as its first argument,
     the @i{symbol} as its second argument,
 and an @i{environment object} (corresponding to the current @i{lexical environment})
      as its third argument.
The @i{macroexpand hook}, in turn, calls the expansion function with the
@i{form} as its first argument and the @i{environment} as its second argument.
The @i{value} of the expansion function, which is passed through
by the @i{macroexpand hook}, is a @i{form}. 
This resulting @i{form} is processed in place of the original @i{symbol}.

If a @i{form} is a @i{symbol} that is not a @i{symbol macro},
then it is the @i{name} of a @i{variable}, and the @i{value} of that
@i{variable} is returned. There are three kinds of variables:
 @i{lexical variables},
 @i{dynamic variables},
and
 @i{constant variables}.
A @i{variable} can store one @i{object}.
The main operations on a @i{variable} are 
 to @i{read}_1 and 
 to @i{write}_1
its @i{value}.

An error of @i{type} @b{unbound-variable} should be signaled if
an @i{unbound variable} is referenced.

@i{Non-constant variables} can be @i{assigned} by using @b{setq} 
or @i{bound}_3 by using @b{let}.
Figure 3--1 lists some @i{defined names} that
are applicable to assigning, binding, and defining @i{variables}.

@format
@group
@noindent
@w{  boundp        let                  progv         }
@w{  defconstant   let*                 psetq         }
@w{  defparameter  makunbound           set           }
@w{  defvar        multiple-value-bind  setq          }
@w{  lambda        multiple-value-setq  symbol-value  }

@noindent
@w{  Figure 3--1: Some Defined Names Applicable to Variables}

@end group
@end format

The following is a description of each kind of variable.

@node Lexical Variables, Dynamic Variables, Symbols as Forms, The Evaluation Model
@subsubsection Lexical Variables

A @i{lexical variable} is a @i{variable} that can be referenced only within 
the @i{lexical scope} of the @i{form} that establishes that @i{variable};
@i{lexical variables} have @i{lexical scope}.
Each time a @i{form} creates a @i{lexical binding} of a @i{variable},
a @i{fresh} @i{binding} is @i{established}.

Within the @i{scope} of a @i{binding} for a @i{lexical variable} @i{name},
uses of that @i{name} as a @i{variable} are considered to be references
to that @i{binding} except where the @i{variable} is @i{shadowed}_2 
by a @i{form} that @i{establishes} a @i{fresh} @i{binding} for that 
@i{variable} @i{name},
or by a @i{form} that locally @i{declares} the @i{name} @b{special}.

A @i{lexical variable} always has a @i{value}.
There is no @i{operator} that introduces a @i{binding} for a
@i{lexical variable} without giving it an initial @i{value}, nor
is there any @i{operator} that can make a @i{lexical variable} be @i{unbound}.

@i{Bindings} of @i{lexical variables} are found in the @i{lexical environment}.

@node Dynamic Variables, Constant Variables, Lexical Variables, The Evaluation Model
@subsubsection Dynamic Variables

A @i{variable} is a @i{dynamic variable} if one of the following
conditions hold:

@table @asis

@item @t{*}  
It is locally declared or globally proclaimed @b{special}.

@item @t{*}  
It occurs textually within a @i{form} that
creates a @i{dynamic binding} for a @i{variable} of the @i{same} @i{name},
and the @i{binding} is not @i{shadowed}_2 by a @i{form}
that creates a @i{lexical binding} of the same @i{variable} @i{name}.

@end table

A @i{dynamic variable} can be referenced at any time in any @i{program};
there is no textual limitation on references to @i{dynamic variables}.
At any given time, all @i{dynamic variables} with a given name refer to 
exactly one @i{binding}, either in the @i{dynamic environment}
or in the @i{global environment}.

The @i{value} part of the @i{binding} for a @i{dynamic variable} might
be empty; in this case, the @i{dynamic variable} is said to have no @i{value},
or to be @i{unbound}.  A @i{dynamic variable} can be made @i{unbound}
by using @b{makunbound}.

The effect of @i{binding} a @i{dynamic variable} is to create
a new @i{binding} to which all references to that @i{dynamic variable}
in any @i{program} refer for the duration of the @i{evaluation} of the @i{form}
that creates the @i{dynamic binding}.

A @i{dynamic variable} can be referenced outside the @i{dynamic extent} of
a @i{form} that @i{binds} it.  Such a @i{variable} is sometimes called 
a ``global variable'' but is still in all respects just a @i{dynamic variable}
whose @i{binding} happens to exist in the @i{global environment} rather than in some
@i{dynamic environment}.

A @i{dynamic variable} is @i{unbound}
unless and until explicitly assigned a value, except for 
those variables whose initial value is 
defined in this specification or by an @i{implementation}.

@node Constant Variables, Symbols Naming Both Lexical and Dynamic Variables, Dynamic Variables, The Evaluation Model
@subsubsection Constant Variables

Certain variables, called @i{constant variables}, are reserved as ``named constants.''  
The consequences are undefined if an attempt is made to 
    assign a value to,
 or create
a @i{binding} for a @i{constant variable}, 
except that a `compatible' redefinition of a @i{constant variable}
using @b{defconstant} is permitted; see the @i{macro} @b{defconstant}.

@i{Keywords}, 
@i{symbols} defined by @r{Common Lisp} or the @i{implementation}
  as constant (such as @b{nil}, @b{t}, and @b{pi}),
and @i{symbols} declared as constant using @b{defconstant}
are @i{constant variables}.

@node Symbols Naming Both Lexical and Dynamic Variables, Conses as Forms, Constant Variables, The Evaluation Model
@subsubsection Symbols Naming Both Lexical and Dynamic Variables

The same @i{symbol} can name both 
    a @i{lexical variable} 
and a @i{dynamic variable},
but never in the same @i{lexical environment}.

In the following example, the @i{symbol} @t{x} is used,
at different times, 
    as the @i{name} of a @i{lexical variable}
and as the @i{name} of a @i{dynamic variable}.

@example
 (let ((x 1))            ;Binds a special variable X
   (declare (special x))
   (let ((x 2))          ;Binds a lexical variable X
     (+ x                ;Reads a lexical variable X
        (locally (declare (special x))
                 x))))   ;Reads a special variable X
@result{}  3
@end example

@node Conses as Forms, Special Forms, Symbols Naming Both Lexical and Dynamic Variables, The Evaluation Model
@subsubsection Conses as Forms

A @i{cons} that is used as a @i{form} is called a @i{compound form}.

If the @i{car} of that @i{compound form} is a @i{symbol}, 
that @i{symbol} is the @i{name} of an @i{operator},
and the @i{form} is either a @i{special form}, a @i{macro form},
or a @i{function form}, depending on the @i{function} @i{binding} 
of the @i{operator} in the current @i{lexical environment}.
If the @i{operator} is neither a @i{special operator}
nor a @i{macro name}, it is assumed to be a @i{function name}
(even if there is no definition for such a @i{function}).

If the @i{car} of the @i{compound form} is not a @i{symbol},
then that @i{car} must be a @i{lambda expression},
in which case the @i{compound form} is a @i{lambda form}.

How a @i{compound form} is processed depends on whether it is 
classified as a @i{special form}, a @i{macro form}, 
a @i{function form}, or a @i{lambda form}.

@node Special Forms, Macro Forms, Conses as Forms, The Evaluation Model
@subsubsection Special Forms

A @i{special form} is a @i{form} with special syntax,
special evaluation rules, or both, possibly manipulating the
evaluation environment, control flow, or both.
A @i{special operator} has access to
    the current @i{lexical environment} 
and the current @i{dynamic environment}.
Each @i{special operator} defines the manner in which its @i{subexpressions}
are treated---which are @i{forms}, which are special syntax, @i{etc.}

Some @i{special operators} create new 
lexical or dynamic @i{environments} for use during the 
@i{evaluation} of @i{subforms}
of the @i{special form}.  For example, @b{block} creates a
new @i{lexical environment} that is the same as the one in force
at the point of evaluation of the @b{block} @i{form}
with the addition of a @i{binding} of the @b{block} name
to an @i{exit point} from the @b{block}.

The set of @i{special operator} @i{names} is fixed in @r{Common Lisp}; 
no way is provided for the user to define a @i{special operator}.
Figure 3--2 lists all of the @r{Common Lisp} @i{symbols}
that have definitions as @i{special operators}.

@format
@group
@noindent
@w{  block      let*                  return-from      }
@w{  catch      load-time-value       setq             }
@w{  eval-when  locally               symbol-macrolet  }
@w{  flet       macrolet              tagbody          }
@w{  function   multiple-value-call   the              }
@w{  go         multiple-value-prog1  throw            }
@w{  if         progn                 unwind-protect   }
@w{  labels     progv                                  }
@w{  let        quote                                  }

@noindent
@w{      Figure 3--2: Common Lisp Special Operators    }

@end group
@end format

@node Macro Forms, Function Forms, Special Forms, The Evaluation Model
@subsubsection Macro Forms

If the @i{operator} names a @i{macro},
its associated @i{macro function} is applied
to the entire @i{form} and the result of that application is
used in place of the original @i{form}.

Specifically, a @i{symbol} names a @i{macro} in a given @i{lexical environment} if
@b{macro-function} is @i{true} of the 
@i{symbol} and that @i{environment}.
The @i{function} returned by @b{macro-function}
is a @i{function} of two arguments, called the
expansion function.
The expansion function is invoked by calling the @i{macroexpand hook} with
      the expansion function as its first argument,
      the entire @i{macro form} as its second argument,
    and an @i{environment object} (corresponding to the current @i{lexical environment})
      as its third argument.
The @i{macroexpand hook}, in turn, calls the expansion function with the
@i{form} as its first argument and the @i{environment} as its second argument.
The @i{value} of the expansion function, which is passed through
by the @i{macroexpand hook}, is a @i{form}. 
The returned @i{form} is @i{evaluated} in place of the original @i{form}.

The consequences are undefined if a @i{macro function} destructively modifies
any part of its @i{form} argument.

A @i{macro name} is not a @i{function designator},
and cannot be used as the @i{function} argument to @i{functions} 
such as @b{apply}, @b{funcall}, or @b{map}.

An @i{implementation} is free to implement a @r{Common Lisp} @i{special operator}
as a @i{macro}.  An @i{implementation} is free to implement any
@i{macro} @i{operator} as a @i{special operator}, but only
if an equivalent definition of the @i{macro} is also provided.

Figure 3--3 lists some @i{defined names} that are applicable
to @i{macros}.

@format
@group
@noindent
@w{  *macroexpand-hook*  macro-function  macroexpand-1  }
@w{  defmacro            macroexpand     macrolet       }

@noindent
@w{    Figure 3--3: Defined names applicable to macros  }

@end group
@end format

@node Function Forms, Lambda Forms, Macro Forms, The Evaluation Model
@subsubsection Function Forms

If the @i{operator} is a @i{symbol} naming a @i{function},
the @i{form} represents a @i{function form},
and the @i{cdr} of the list contains the @i{forms} 
which when evaluated will supply the arguments passed to the @i{function}.

When a @i{function name} is not defined, 
an error of @i{type} @b{undefined-function} should be signaled at run time;
see @ref{Semantic Constraints}.

A @i{function form} is evaluated as follows:

The @i{subforms} in the @i{cdr} of the original @i{form}
are evaluated in left-to-right order in the current lexical and 
dynamic @i{environments}.  The @i{primary value} of each
such @i{evaluation} becomes an @i{argument} to the named @i{function};
any additional @i{values} returned by the @i{subforms} are discarded.

The @i{functional value} of the @i{operator} 
is retrieved from the @i{lexical environment},
and that @i{function} is invoked with the indicated arguments.

Although the order of @i{evaluation} of 
the @i{argument} @i{subforms} themselves is 
strictly left-to-right, it is not specified whether 
the definition of the @i{operator} in a @i{function form} is looked up 
before the @i{evaluation} of the @i{argument} @i{subforms},
after the @i{evaluation} of the @i{argument} @i{subforms},
or between the @i{evaluation} of any two @i{argument} @i{subforms} 
if there is more than one such @i{argument} @i{subform}.  
For example, the following might return 23 or~24.

@example
 (defun foo (x) (+ x 3))
 (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))
 (foo (progn (bar) 20))
@end example

A @i{binding} for a @i{function name} can be @i{established} in 
one of several ways.  A @i{binding} for a @i{function name} in 
the @i{global environment} can be @i{established} by 
 @b{defun},
 @b{setf} of @b{fdefinition},
 @b{setf} of @b{symbol-function},
 @b{ensure-generic-function},
 @b{defmethod} (implicitly, due to @b{ensure-generic-function}),
or
 @b{defgeneric}.
A @i{binding} for a @i{function name} in the @i{lexical environment}
can be @i{established} by
   @b{flet}
or @b{labels}.

Figure 3--4 lists some @i{defined names} that are applicable to @i{functions}.

@format
@group
@noindent
@w{  apply                 fdefinition  mapcan               }
@w{  call-arguments-limit  flet         mapcar               }
@w{  complement            fmakunbound  mapcon               }
@w{  constantly            funcall      mapl                 }
@w{  defgeneric            function     maplist              }
@w{  defmethod             functionp    multiple-value-call  }
@w{  defun                 labels       reduce               }
@w{  fboundp               map          symbol-function      }

@noindent
@w{      Figure 3--4: Some function-related defined names    }

@end group
@end format

@node Lambda Forms, Self-Evaluating Objects, Function Forms, The Evaluation Model
@subsubsection Lambda Forms

A @i{lambda form} is similar to a @i{function form}, except that
the @i{function name} is replaced by a @i{lambda expression}.

A @i{lambda form} is equivalent to using @i{funcall} of a
@i{lexical closure} of the @i{lambda expression} on the given @i{arguments}.
(In practice, some compilers are more likely to produce inline code 
for a @i{lambda form} than for an arbitrary named function 
that has been declared @b{inline}; however, such a difference
is not semantic.)

For further information, see @ref{Lambda Expressions}.

@node Self-Evaluating Objects, Examples of Self-Evaluating Objects, Lambda Forms, The Evaluation Model
@subsubsection Self-Evaluating Objects

A @i{form} that is neither a @i{symbol} nor a @i{cons} is 
defined to be a @i{self-evaluating object}.  @i{Evaluating}
such an @i{object} @i{yields} the @i{same} @i{object} 
as a result.

Certain specific @i{symbols} and @i{conses} might also happen 
to be ``self-evaluating'' but only as a special case of a more 
general set of rules for the @i{evaluation} of @i{symbols} and
@i{conses}; such @i{objects} are not considered to be
@i{self-evaluating objects}.

The consequences are undefined if @i{literal objects} (including
@i{self-evaluating objects}) are destructively modified.

@node Examples of Self-Evaluating Objects,  , Self-Evaluating Objects, The Evaluation Model
@subsubsection Examples of Self-Evaluating Objects

@i{Numbers}, @i{pathnames}, and @i{arrays} are examples of
@i{self-evaluating objects}.

@example
 3 @result{}  3
 #c(2/3 5/8) @result{}  #C(2/3 5/8)
 #p"S:[BILL]OTHELLO.TXT" @result{}  #P"S:[BILL]OTHELLO.TXT"
 #(a b c) @result{}  #(A B C)
 "fred smith" @result{}  "fred smith"
@end example

@node Lambda Expressions, Closures and Lexical Binding, The Evaluation Model, Evaluation
@subsection Lambda Expressions

In a @i{lambda expression},
the body is evaluated in a lexical @i{environment} that is formed by
adding the @i{binding} of 
each @i{parameter} in the @i{lambda list}
with the corresponding @i{value} from the @i{arguments}
to the current lexical @i{environment}.

For further discussion of how @i{bindings} are @i{established} 
based on the @i{lambda list}, see @ref{Lambda Lists}.

The body of a @i{lambda expression} is an @i{implicit progn};
the @i{values} it returns are returned by the @i{lambda expression}.

@node Closures and Lexical Binding, Shadowing, Lambda Expressions, Evaluation
@subsection Closures and Lexical Binding

A @i{lexical closure} is a @i{function} that can refer to and alter
the values of @i{lexical bindings} @i{established} by @i{binding} @i{forms}
that textually include the function definition.

Consider this code, where @t{x} is not declared @b{special}:

@example
 (defun two-funs (x)
   (list (function (lambda () x))
         (function (lambda (y) (setq x y)))))
 (setq funs (two-funs 6))
 (funcall (car funs)) @result{}  6
 (funcall (cadr funs) 43) @result{}  43
 (funcall (car funs)) @result{}  43
@end example

The @b{function} @i{special form} coerces a 
@i{lambda expression} into a @i{closure} in which the 
@i{lexical environment} in effect when the @i{special form} is
evaluated is captured along with the @i{lambda expression}.

The function @t{two-funs} returns a @i{list} of two 
@i{functions}, each of which refers to the @i{binding} of the
variable @t{x} created on entry to the function @t{two-funs} when it
was called.
This variable has the value @t{6}
initially, but @b{setq} can alter this @i{binding}.
The @i{lexical closure} created for the first 
@i{lambda expression} does not ``snapshot'' the @i{value} @t{6} for @t{x}
when the @i{closure} is created; rather it captures the @i{binding} of @t{x}.
The second @i{function} can be used to alter the @i{value} in the same (captured)
@i{binding} (to @t{43}, in the example), and
this altered variable binding then affects the value returned by the first @i{function}.

In situations where a @i{closure} of a 
@i{lambda expression} over the same set of @i{bindings} may be
produced more than once, the various resulting @i{closures} may
or may not be @i{identical}, at the discretion of the @i{implementation}.
That is, two @i{functions} that are behaviorally
indistinguishable might or might not be @i{identical}.
Two @i{functions} that are behaviorally distinguishable are @i{distinct}.
For example:

@example
 (let ((x 5) (funs '()))
   (dotimes (j 10)                          
     (push #'(lambda (z)                        
               (if (null z) (setq x 0) (+ x z)))
           funs))
   funs)
@end example

The result of the above @i{form} is a @i{list} of ten @i{closures}.
Each requires only the @i{binding} of @t{x}.
It is the same @i{binding} in each case, 
but the ten @i{closure} @i{objects} might or might not be @i{identical}.
On the other hand, the result of the @i{form}

@example
 (let ((funs '()))     
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z)
                        (if (null z) (setq x 0) (+ x z))))
             funs)))
  funs)
@end example

is also a @i{list} of ten @i{closures}.
However, in this case no two of the @i{closure} @i{objects} can
be @i{identical} because each @i{closure} is closed over a distinct
@i{binding} of @t{x}, and these @i{bindings} can be behaviorally
distinguished because of the use of @b{setq}.

The result of the @i{form}

@example
 (let ((funs '()))
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z) (+ x z)))
            funs)))
   funs)
@end example

is a @i{list} of ten @i{closure} @i{objects} that
might or might not be @i{identical}.
A different @i{binding} of @t{x} is involved for
each @i{closure}, but the @i{bindings} cannot be distinguished
because their values are the @i{same} and immutable (there being no occurrence
of @b{setq} on @t{x}).  A compiler could internally
transform the @i{form} to

@example
 (let ((funs '()))
   (dotimes (j 10)
     (push (function (lambda (z) (+ 5 z)))
           funs))
  funs)
@end example

where the @i{closures} may be @i{identical}.

It is possible that a @i{closure} does not
close over any variable bindings.
In the code fragment

@example
 (mapcar (function (lambda (x) (+ x 2))) y)
@end example

the function @t{(lambda (x) (+ x 2))} contains no references to any outside
object. In this case, the same @i{closure} might be returned
for all evaluations of the @b{function} @i{form}.

@node Shadowing, Extent, Closures and Lexical Binding, Evaluation
@subsection Shadowing

If two @i{forms} that @i{establish} @i{lexical bindings} with
the same @i{name} N are textually nested, then references to N
within the inner @i{form} refer to the @i{binding} established by
the inner @i{form}; the inner @i{binding} for N
@i{shadows}
@IGindex shadow
 the outer @i{binding} for N.  Outside the inner
@i{form} but inside the outer one, references to N refer to the
@i{binding} established by the outer @i{form}.  For example:

@example
 (defun test (x z)
   (let ((z (* x 2)))
     (print z))
   z)
@end example

The @i{binding} of the variable @t{z} by
@b{let} shadows
the @i{parameter} binding for the function @t{test}.  The reference to the
variable @t{z} in the @b{print} @i{form} refers to the @b{let} binding.
The reference to @t{z} at the end of the function @t{test} 
refers to the @i{parameter} named @t{z}.

Constructs that are lexically scoped act as if new names were
generated for each @i{object} on each execution.  Therefore,
dynamic shadowing cannot occur.  For example:

@example
 (defun contorted-example (f g x)
   (if (= x 0)
       (funcall f)
       (block here
          (+ 5 (contorted-example g
                                  #'(lambda () (return-from here 4))
                                  (- x 1))))))
@end example

Consider the call @t{(contorted-example nil nil 2)}.  This produces
@t{4}.  During the course of execution, there are three
calls to @t{contorted-example}, interleaved with two 
blocks:

@example
 (contorted-example nil nil 2)
   (block here_1 ...)
     (contorted-example nil #'(lambda () (return-from here_1 4)) 1)
       (block here_2 ...)
         (contorted-example #'(lambda () (return-from here_1 4))
                            #'(lambda () (return-from here_2 4))
                            0)
             (funcall f)
                    where f @result{}  #'(lambda () (return-from here_1 4))
                 (return-from here_1 4)
@end example

At the time the @t{funcall} is executed
there are two @b{block} @i{exit points} outstanding, each apparently
named @t{here}.
The @b{return-from} @i{form} executed as a result of the @t{funcall}
operation
refers to the outer outstanding @i{exit point}
(here_1), not the
inner one (here_2).
It
refers to that @i{exit point} textually visible at the point of
execution of @b{function}
(here abbreviated by the @t{#'} syntax) that resulted
in creation of the @i{function} @i{object} actually invoked by 
@b{funcall}.                       

If, in this example, one were to change the @t{(funcall f)} to
@t{(funcall g)}, then the value of the call @t{(contorted-example nil nil 2)}
would be @t{9}.  The value would change because 
@b{funcall} would cause the
execution of @t{(return-from here_2 4)}, thereby causing
a return from the inner @i{exit point} (here_2).
When that occurs, the value @t{4} is returned from the
middle invocation of @t{contorted-example}, @t{5} is added to that
to get @t{9}, and that value is returned from the outer block
and the outermost call to @t{contorted-example}.  The point
is that the choice of @i{exit point}
returned from has nothing to do with its
being innermost or outermost; rather,
it depends on the lexical environment
that is packaged up with a @i{lambda expression} when
@b{function} is executed.

@node Extent, Return Values, Shadowing, Evaluation
@subsection Extent

@t{Contorted-example} works only because the
@i{function} named by @t{f} is invoked during the @i{extent} of the 
@i{exit point}.
Once the flow of execution has left the block,
the @i{exit point} is @i{disestablished}.  For example:

@example
 (defun invalid-example ()
   (let ((y (block here #'(lambda (z) (return-from here z)))))
     (if (numberp y) y (funcall y 5))))
@end example

One might expect the call @t{(invalid-example)} to produce @t{5}
by the following incorrect reasoning:
@b{let} binds @t{y} to the
value of @b{block}; this value is a @i{function} resulting
from the @i{lambda expression}.  Because @t{y} is not a number, it is
invoked on the value @t{5}.  The @b{return-from} should then
return this value from the                      
@i{exit point} named @t{here}, thereby
exiting from the block again and giving @t{y} the value @t{5}
which, being a number, is then returned as the value of the call
to @t{invalid-example}.

The argument fails only because @i{exit points} have 
@i{dynamic extent}.  The argument is correct up to the execution of
@b{return-from}.  The execution of @b{return-from}
should signal an error of @i{type} @b{control-error}, however, not
because it cannot refer to the @i{exit point}, but because it
does correctly refer to an @i{exit point} and that 
@i{exit point} has been @i{disestablished}.

A reference by name to a dynamic @i{exit point} binding such as
a @i{catch tag} refers to the most recently 
@i{established} @i{binding} of that name that has not been 
@i{disestablished}.  For example:

@example
 (defun fun1 (x)
   (catch 'trap (+ 3 (fun2 x))))
 (defun fun2 (y)
   (catch 'trap (* 5 (fun3 y))))
 (defun fun3 (z)
   (throw 'trap z))
@end example

Consider the call @t{(fun1 7)}.  The result is @t{10}.  At the time
the @b{throw} is executed, there are two outstanding catchers with the
name @t{trap}: one established within procedure @t{fun1}, and the other
within procedure @t{fun2}.  The latter is the more recent, and so the
value @t{7} is returned from @b{catch} in @t{fun2}.
Viewed from within @t{fun3}, the @b{catch} 
in @t{fun2} shadows the one in @t{fun1}.
Had @t{fun2} been defined as

@example
 (defun fun2 (y)
   (catch 'snare (* 5 (fun3 y))))
@end example

then the two @i{exit points} 
would have different @i{names}, and therefore the one
in @t{fun1} would not be shadowed.  The result would then have been @t{7}.

@node Return Values,  , Extent, Evaluation
@subsection Return Values

Ordinarily the result of calling a @i{function} is a single @i{object}.
Sometimes, however, it is convenient for a function to compute several
@i{objects} and return them.

In order to receive other than exactly one value from a @i{form},
one of several @i{special forms} or @i{macros} must be used to request those
values.  If a @i{form} produces @i{multiple values} which were not
requested in this way, then the first value is given to the caller and
all others are discarded; if the @i{form} produces zero values,
then the caller receives @b{nil} as a value.

Figure 3--5 lists 
some @i{operators} for receiving @i{multiple values}_2.
These @i{operators} can be used to specify 
    one or more @i{forms} to @i{evaluate} 
and where to put the @i{values} returned by those @i{forms}.

@format
@group
@noindent
@w{  multiple-value-bind  multiple-value-prog1  return-from  }
@w{  multiple-value-call  multiple-value-setq   throw        }
@w{  multiple-value-list  return                             }

@noindent
@w{  Figure 3--5: Some operators applicable to receiving multiple values}

@end group
@end format

The @i{function} @b{values} can produce @i{multiple values}_2.
@t{(values)} returns zero values;
@t{(values @i{form})} returns the @i{primary value} returned by @i{form};
@t{(values @i{form1} @i{form2})} returns two values,
    the @i{primary value} of @i{form1}
and the @i{primary value} of @i{form2};
and so on.

See @b{multiple-values-limit} and @b{values-list}.

@c end of including concept-eval

@node Compilation, Declarations, Evaluation, Evaluation and Compilation
@section Compilation

@c including concept-compile

@menu
* Compiler Terminology::	
* Compilation Semantics::	
* File Compilation::		
* Literal Objects in Compiled Files::  
* Exceptional Situations in the Compiler::  
@end menu

@node Compiler Terminology, Compilation Semantics, Compilation, Compilation
@subsection Compiler Terminology

The following terminology is used in this section.

The @i{compiler}
@IGindex compiler
 is a utility that translates code into an
@i{implementation-dependent} form that might be represented or
executed efficiently.
The term @i{compiler}
@IGindex compiler
 refers to both of the @i{functions}
@b{compile} and @b{compile-file}.

The term @i{compiled code}
@IGindex compiled code
 refers to 
@i{objects} representing compiled programs, such as @i{objects} constructed
by @b{compile} or by @b{load} when @i{loading} a @i{compiled file}.

The term @i{implicit compilation}
@IGindex implicit compilation
 refers to @i{compilation}
performed during @i{evaluation}.

The term @i{literal object}
@IGindex literal object
 refers to 
     a quoted @i{object} 
  or a @i{self-evaluating object} 
  or an @i{object} that is a substructure of such an @i{object}.
A @i{constant variable} is not itself a @i{literal object}.

The term @i{coalesce}
@IGindex coalesce
 is defined as follows.
Suppose @t{A} and @t{B} are two @i{literal constants} in the @i{source code},
and that @t{A'} and @t{B'} are the corresponding @i{objects} in the @i{compiled code}.
If @t{A'} and @t{B'} are @b{eql} but
@t{A} and @t{B} are not @b{eql}, then it is said
that @t{A} and @t{B} have been coalesced by the compiler.

The term @i{minimal compilation}
@IGindex minimal compilation
 refers to actions the compiler
must take at @i{compile time}. These actions are specified in 
@ref{Compilation Semantics}.

The verb @i{process}
@IGindex process
 refers to performing @i{minimal compilation},
determining the time of evaluation for a @i{form},
and possibly @i{evaluating} that @i{form} (if required).

The term @i{further compilation}
@IGindex further compilation
 refers to
@i{implementation-dependent} compilation beyond @i{minimal compilation}.
That is, @i{processing} does not imply complete compilation.
Block compilation and generation of machine-specific instructions are 
examples of further compilation.
Further compilation is permitted to take place at @i{run time}.

Four different @i{environments} relevant to compilation are
distinguished:
  the @i{startup environment},
  the @i{compilation environment},
  the @i{evaluation environment}, and
  the @i{run-time environment}.

The @i{startup environment}
@IGindex startup environment
 is
the @i{environment} of the @i{Lisp image} 
from which the @i{compiler} was invoked.

The @i{compilation environment}
@IGindex compilation environment
 is maintained by the compiler
and is used to hold definitions and declarations to be used internally
by the compiler.  Only those parts of a definition needed for correct
compilation are saved. The @i{compilation environment} is used
as the @i{environment} @i{argument} to macro expanders called by
the compiler. It is unspecified whether a definition available in the
@i{compilation environment} can be used in an @i{evaluation}
initiated in the @i{startup environment} or @i{evaluation environment}.

The @i{evaluation environment}
@IGindex evaluation environment
 is a @i{run-time environment}
in which macro expanders and code specified by @b{eval-when}
to be evaluated are evaluated.  All evaluations initiated by the
@i{compiler} take place in the @i{evaluation environment}.

The @i{run-time environment}
@IGindex run-time environment
 is the 
@i{environment} in which the program being compiled will be executed.

The @i{compilation environment} inherits from
the @i{evaluation environment},
and the @i{compilation environment} and @i{evaluation environment} 
might be @i{identical}.
The @i{evaluation environment} inherits from
the @i{startup environment}, 
and the @i{startup environment} and @i{evaluation environment} 
might be @i{identical}.

The term @i{compile time}
@IGindex compile time
 refers to the duration of time that
the compiler is processing @i{source code}.
At @i{compile time},
only the @i{compilation environment} 
and  the @i{evaluation environment}
are available.

The term @i{compile-time definition}
@IGindex compile-time definition
 refers to a definition in
the @i{compilation environment}.
For example, when compiling a file, 
the definition of a function might be retained in the @i{compilation environment} 
if it is declared @b{inline}. 
This definition might not be available in the @i{evaluation environment}.

The term @i{run time}
@IGindex run time
 refers to the duration of time that the
loader is loading compiled code or compiled code is being executed.
At run time, only the @i{run-time environment} is available.

The term @i{run-time definition}
@IGindex run-time definition
 refers to a definition in the
@i{run-time environment}.

The term @i{run-time compiler}
@IGindex run-time compiler
 refers to the @i{function} @b{compile}
or @i{implicit compilation}, for which the compilation and run-time 
@i{environments} are maintained in the same @i{Lisp image}.
Note that when the @i{run-time compiler} is used,
the @i{run-time environment} 
and @i{startup environment} 
are the same.

@node Compilation Semantics, File Compilation, Compiler Terminology, Compilation
@subsection Compilation Semantics

Conceptually, compilation is a process that traverses code, performs
certain kinds of syntactic and semantic analyses using information
(such as proclamations and @i{macro} definitions) present in the
@i{compilation environment}, and produces equivalent, possibly
more efficient code.

@menu
* Compiler Macros::		
* Purpose of Compiler Macros::	
* Naming of Compiler Macros::	
* When Compiler Macros Are Used::  
* Notes about the Implementation of Compiler Macros::  
* Minimal Compilation::		
* Semantic Constraints::	
@end menu

@node Compiler Macros, Purpose of Compiler Macros, Compilation Semantics, Compilation Semantics
@subsubsection Compiler Macros

A @i{compiler macro} can be defined for a @i{name}
that also names a @i{function} or @i{macro}.
That is, it is possible for a
@i{function name} to name both a @i{function} and a @i{compiler macro}.

A @i{function name} names a @i{compiler macro} if @b{compiler-macro-function}
is @i{true} of the @i{function name} in the @i{lexical environment} in which
it appears.  Creating a @i{lexical binding} for the @i{function name}
not only creates a new local @i{function} or
@i{macro} definition, but also @i{shadows}_2 the @i{compiler macro}.

The @i{function} returned by @b{compiler-macro-function}
is a @i{function} of two arguments, called the
expansion function.  To expand a @i{compiler macro},
the expansion function is invoked by calling the @i{macroexpand hook} with
      the expansion function as its first argument,
      the entire compiler macro @i{form} as its second argument,
  and the current compilation @i{environment} 
       (or with the current lexical @i{environment},
 	 if the @i{form} is being processed by something
	 other than @b{compile-file}) 
       as its third argument.
The @i{macroexpand hook}, in turn, calls the expansion function with the
@i{form} as its first argument and the @i{environment} as its second argument.
The return value from the expansion function, which is passed through
by the @i{macroexpand hook}, might either be the @i{same} @i{form}, 
or else a form that can, at the discretion of the @i{code} doing the expansion, 
be used in place of the original @i{form}.

@format
@group
@noindent
@w{  *macroexpand-hook*  compiler-macro-function  define-compiler-macro  }

@noindent
@w{        Figure 3--6: Defined names applicable to compiler macros      }

@end group
@end format

@node Purpose of Compiler Macros, Naming of Compiler Macros, Compiler Macros, Compilation Semantics
@subsubsection Purpose of Compiler Macros

The purpose of the @i{compiler macro} facility is to permit 
selective source code transformations as optimization advice 
to the @i{compiler}.  When a @i{compound form} is being
processed (as by the compiler), if the @i{operator} names a
@i{compiler macro} then the @i{compiler macro function} may be
invoked on the form, and the resulting expansion recursively processed
in preference to performing the usual processing on the original @i{form}
according to its normal interpretation as a @i{function form} or
@i{macro form}.

A @i{compiler macro function}, like a @i{macro function},
is a @i{function} of two @i{arguments}: the entire call @i{form}
and the @i{environment}. Unlike an ordinary @i{macro function}, a 
@i{compiler macro function} can decline to provide an expansion merely by
returning a value that is the @i{same} as the original @i{form}.
The consequences are undefined if a @i{compiler macro function}
destructively modifies any part of its @i{form} argument.

The @i{form} passed to the compiler macro function can either be a @i{list}
whose @i{car} is the function name, or a @i{list} whose @i{car} is
@b{funcall} and whose @i{cadr} is a list @t{(function @i{name})};
note that this affects destructuring of the form argument by the 
@i{compiler macro function}.
@b{define-compiler-macro} arranges for destructuring of arguments to be
performed correctly for both possible formats.

When @b{compile-file} chooses to expand a @i{top level form} that is
a @i{compiler macro} @i{form}, the expansion is also treated as a @i{top level form}
for the purposes of @b{eval-when} processing; see @ref{Processing of Top Level Forms}.

@node Naming of Compiler Macros, When Compiler Macros Are Used, Purpose of Compiler Macros, Compilation Semantics
@subsubsection Naming of Compiler Macros

@i{Compiler macros} may be defined for @i{function names} that name
@i{macros} as well as @i{functions}.  

@i{Compiler macro} definitions are strictly global.  There is no provision
for defining local @i{compiler macros} in the way that @b{macrolet}
defines local @i{macros}.  Lexical bindings of a function name shadow any
compiler macro definition associated with the name as well as its 
global @i{function} or @i{macro} definition.

Note that the presence of a compiler macro definition does not affect
the values returned by

functions that access @i{function} definitions (@i{e.g.}, @b{fboundp})
or @i{macro} definitions (@i{e.g.}, @b{macroexpand}).
Compiler macros are global, and the function
@b{compiler-macro-function} is sufficient to resolve their interaction
with other lexical and global definitions.

@node When Compiler Macros Are Used, Notes about the Implementation of Compiler Macros, Naming of Compiler Macros, Compilation Semantics
@subsubsection When Compiler Macros Are Used

The presence of a @i{compiler macro} definition for a @i{function} or @i{macro}
indicates that it is desirable for the @i{compiler} to use the expansion
of the @i{compiler macro} instead of the original @i{function form} or
@i{macro form}.  However, no language processor
(compiler, evaluator, or other code walker) is ever required to actually
invoke @i{compiler macro functions}, or to 
make use of the resulting expansion if it does invoke 
a @i{compiler macro function}.

When the @i{compiler} encounters a @i{form} during processing that represents
a call to a @i{compiler macro} @i{name} (that is not declared @b{notinline}),
the @i{compiler} might expand the @i{compiler macro}, 
and might use the expansion in place of the original @i{form}.

When @b{eval} encounters a @i{form} during processing that represents 
a call to a @i{compiler macro} @i{name} (that is not declared @b{notinline}),
@b{eval} might expand the @i{compiler macro},
and might use the expansion in place of the original @i{form}.

There are two situations in which a @i{compiler macro} definition must not be
applied by any language processor:

@table @asis

@item @t{*}  
The global function name binding associated with the compiler
 macro is shadowed by a lexical binding of the function name.

@item @t{*}  
The function name has been declared or proclaimed @b{notinline} and
 the call form appears within the scope of the declaration.
@end table

It is unspecified whether @i{compiler macros} are expanded or used in any other
situations.

@node Notes about the Implementation of Compiler Macros, Minimal Compilation, When Compiler Macros Are Used, Compilation Semantics
@subsubsection Notes about the Implementation of Compiler Macros

Although it is technically permissible, as described above,
for @b{eval} to treat @i{compiler macros} in the same situations
as @i{compiler} might, this is not necessarily a good idea in
@i{interpreted implementations}.

@i{Compiler macros} exist for the purpose of trading compile-time speed
for run-time speed.  Programmers who write @i{compiler macros} tend to
assume that the @i{compiler macros} can take more time than normal @i{functions}
and @i{macros} in order to produce code which is especially optimal for use
at run time.  Since @b{eval} in an @i{interpreted implementation}
might perform semantic analysis of the same form multiple times, it might be 
inefficient in general for the @i{implementation} to choose to call
@i{compiler macros} on every such @i{evaluation}.

Nevertheless, the decision about what to do in these situations is left to
each @i{implementation}.

@node Minimal Compilation, Semantic Constraints, Notes about the Implementation of Compiler Macros, Compilation Semantics
@subsubsection Minimal Compilation

@i{Minimal compilation} is defined as follows:

@table @asis

@item @t{*}  
All @i{compiler macro}
@IGindex compiler macro
 calls appearing in the
@i{source code} being compiled are expanded, if at all, at compile time;
they will not be expanded at run time.

@item @t{*}  
All @i{macro}
@IGindex macro
 and 
@i{symbol macro}
@IGindex symbol macro
 calls
appearing in the source code being compiled are expanded at compile time
in such a way that they will not be expanded again at run time.
@b{macrolet}
@IRindex macrolet

and
@b{symbol-macrolet}
@IRindex symbol-macrolet

are effectively replaced by
@i{forms} corresponding to their bodies in which calls to 
@i{macros} are replaced by their expansions.

@item @t{*}  
The first @i{argument} in a @b{load-time-value}
@IRindex load-time-value

@i{form} 
in @i{source code} processed by @b{compile}
@IRindex compile

is @i{evaluated} at @i{compile time};
in @i{source code} processed by @b{compile-file}
@IRindex compile-file
, 
the compiler arranges for it to be @i{evaluated} at @i{load time}.
In either case, the result of the @i{evaluation}
is remembered and used later as the value of the 
@b{load-time-value} @i{form} at @i{execution time}.

@end table

@node Semantic Constraints,  , Minimal Compilation, Compilation Semantics
@subsubsection Semantic Constraints

All @i{conforming programs} must obey the following constraints,
which are designed to minimize the observable differences 
between compiled and interpreted programs:

@table @asis

@item @t{*}  
Definitions of any referenced @i{macros}
must be present in the @i{compilation environment}.  
Any @i{form} that is a @i{list}
beginning with a @i{symbol} that does not name a
@i{special operator} or a @i{macro} defined in the 
@i{compilation environment} is treated by the compiler as a 
function call.

@item @t{*}  
@b{Special} proclamations for @i{dynamic variables}
must be made in the @i{compilation environment}.  Any @i{binding}
for which there is no @b{special} declaration or proclamation in
the @i{compilation environment} is treated by the compiler as
a @i{lexical binding}.

@item @t{*}  
The definition of a function that is defined and
declared @b{inline} in the @i{compilation environment} must be
the same at run time.

@item @t{*}  
Within a @i{function} named F, the compiler may
(but is not required to)
assume that an apparent recursive call to a @i{function} named F 
refers to the same definition of F,
unless that function has been declared @b{notinline}.
The consequences of redefining such a recursively defined @i{function} F 
while it is executing are undefined.

@item @t{*}  
A call within a file to a named function that is
defined in the same file refers to that function, unless that function
has been declared @b{notinline}.  The consequences are unspecified
if functions are redefined individually at run time or multiply
defined in the same file.

@item @t{*}  
The argument syntax and number of return values for
all functions whose @b{ftype} is declared at compile time must
remain the same at run time.

@item @t{*}  
@i{Constant variables} defined in
the @i{compilation environment} must have a @i{similar} value at
run time.  A reference to 
a @i{constant variable} 
in @i{source code} is equivalent to a reference to 
a @i{literal} @i{object} that is the @i{value} of the @i{constant variable}.

@item @t{*}  
Type definitions made with @b{deftype} or
@b{defstruct} in the @i{compilation environment} must
retain the same definition at run time.  Classes defined by @b{defclass}
in the @i{compilation environment} must be defined
at run time to have the same @i{superclasses} and same 
@i{metaclass}.

This implies that @i{subtype}/@i{supertype} relationships of 
@i{type specifiers} must not change between @i{compile time} and @i{run time}.  

@item @t{*}  
Type declarations present in the compilation 
@i{environment} must accurately describe the corresponding values at run time;
otherwise, the consequences are undefined.  It is permissible
for an unknown @i{type} to appear in a declaration at 
compile time, though a warning might be signaled in such a case.

@item @t{*}  
Except in the situations explicitly listed above, a
@i{function} defined in the @i{evaluation environment}
is permitted to have a different definition or a different @i{signature}
at run time, and the run-time definition prevails.

@end table

@i{Conforming programs} should not be written using any additional
assumptions about consistency between the run-time 
@i{environment} and the startup, evaluation, and compilation 
@i{environments}.

Except where noted, when a compile-time and a run-time definition are
different, one of the following occurs at run time:

@table @asis

@item @t{*}  
an error of @i{type} @b{error} is signaled
@item @t{*}  
the compile-time definition prevails
@item @t{*}  
the run-time definition prevails

@end table

If the @i{compiler} processes a @i{function form} whose @i{operator} 
is not defined at compile time, no error is signaled at compile time.

@node File Compilation, Literal Objects in Compiled Files, Compilation Semantics, Compilation
@subsection File Compilation

The @i{function} @b{compile-file} performs compilation of 
@i{forms} in a file following the rules specified in @ref{Compilation Semantics},
and produces an output file that can be loaded by using @b{load}.

Normally, the @i{top level forms} appearing in a file compiled with
@b{compile-file} are evaluated only when the resulting
compiled file is loaded, and not when the file is compiled.  However,
it is typically the case that some forms in the file need to be evaluated
at compile time so the
remainder of the file can be read and compiled correctly.

The @b{eval-when} @i{special form} can be used to control
whether a @i{top level form} is evaluated at compile time, load
time, or both.  It is possible to specify any of three situations with
@b{eval-when}, denoted by the symbols @t{:compile-toplevel},
@t{:load-toplevel}, and @t{:execute}.  For top level 
@b{eval-when} forms, @t{:compile-toplevel} specifies that the
compiler must evaluate the body at compile time, and @t{:load-toplevel} specifies that the compiler must arrange to evaluate
the body at load time. For non-top level @b{eval-when} forms,
@t{:execute} specifies that the body must be executed in the run-time
@i{environment}.

The behavior of this @i{form} can be more precisely understood in
terms of a model of how @b{compile-file} processes forms in
a file to be compiled. There are two processing modes, called
``not-compile-time'' and ``compile-time-too''.

Successive forms are read from the file by @b{compile-file}
and processed in not-compile-time mode; in this mode, 
@b{compile-file} arranges for forms to be evaluated only at load time
and not at compile time.  When @b{compile-file} is in
compile-time-too mode, forms are evaluated both at compile time and
load time.

@menu
* Processing of Top Level Forms::  
* Processing of Defining Macros::  
* Constraints on Macros and Compiler Macros::  
@end menu

@node Processing of Top Level Forms, Processing of Defining Macros, File Compilation, File Compilation
@subsubsection Processing of Top Level Forms

Processing of @i{top level forms} in the file compiler is defined
as follows:

@table @asis

@item 1.  
If the @i{form} is a @i{compiler macro form}
(not disabled by a @b{notinline} @i{declaration}),
the @i{implementation} might or might not choose to compute
the @i{compiler macro expansion} of the @i{form} and,
having performed the expansion, might or might not choose to process the result
as a @i{top level form} in the same processing mode
(compile-time-too or not-compile-time).
If it declines to obtain or use the expansion, it must process the original @i{form}.

@item 2.  
If the form is a @i{macro form},
its @i{macro expansion} is computed and processed as a 
@i{top level form} in
the same processing mode (compile-time-too or not-compile-time).

@item 3.  
If the form is a @b{progn} form, each of its
body @i{forms} is sequentially processed as a 
@i{top level form} in the same processing mode.

@item 4.  
If the form is a @b{locally}, 
@b{macrolet}, or @b{symbol-macrolet}, 
@b{compile-file} establishes the appropriate bindings and processes the
body forms as @i{top level forms} with those bindings in effect
in the same processing mode.  (Note that this implies that the lexical
@i{environment} in which @i{top level forms} are processed
is not necessarily the @i{null lexical environment}.)

@item 5.  
If the form is an @b{eval-when}
@IRindex eval-when
 form, it is
handled according to Figure 3--7.

  plus .5 fil
\offinterlineskip
@format
@group
@noindent
@w{  @b{CT}   @b{LT}   @b{E}    @b{Mode}  @b{Action}    @b{New Mode}          }
@w{  _________________________________________________}
@w{  Yes  Yes  ---  ---   Process   compile-time-too  }
@w{  No   Yes  Yes   CTT  Process   compile-time-too  }
@w{  No   Yes  Yes   NCT  Process   not-compile-time  }
@w{  No   Yes  No   ---   Process   not-compile-time  }
@w{  Yes  No   ---  ---   Evaluate  ---               }
@w{  No   No   Yes   CTT  Evaluate  ---               }
@w{  No   No   Yes   NCT  Discard   ---               }
@w{  No   No   No   ---   Discard   ---               }
@end group
@end format

@w{  Figure 3--7: EVAL-WHEN processing}

Column @b{CT}   indicates whether @t{:compile-toplevel} is specified.
Column @b{LT}   indicates whether @t{:load-toplevel} is specified.
Column @b{E}    indicates whether @t{:execute} is specified.  
Column @b{Mode} indicates the processing mode; 
		a dash (---) indicates that the processing mode is not relevant.

The @b{Action} column specifies one of three actions:

@table @asis

@item @t{}  
@b{Process:} process the body as @i{top level forms} in the
specified mode.

@item @t{}  
@b{Evaluate:} evaluate the body in the dynamic execution
context of the compiler, using the @i{evaluation environment} as
the global environment and the @i{lexical environment} in which
the @b{eval-when} appears.

@item @t{}  
@b{Discard:} ignore the @i{form}.
@end table

The @b{New Mode} column indicates the new processing mode. 
A dash (---) indicates the compiler remains in its current mode.

@item 6.  
Otherwise, the form is a @i{top level form} that
is not one of the special cases.  In compile-time-too mode, the
compiler first evaluates the form in the evaluation 
@i{environment} and then minimally compiles it.  In not-compile-time
mode, the @i{form} is simply minimally compiled.  All @i{subforms}
are treated as @i{non-top-level forms}.

Note that @i{top level forms} are processed in the order in
which they textually appear in the file and that each 
@i{top level form} read by the compiler is processed before the next is
read.  However, the order of processing (including macro expansion) of
@i{subforms} that are not @i{top level forms} and the order of
further compilation is unspecified as long as Common Lisp semantics
are preserved.

@end table

@b{eval-when} forms cause compile-time evaluation only at
top level.  Both @t{:compile-toplevel} and @t{:load-toplevel} situation specifications
are ignored for @i{non-top-level forms}. For @i{non-top-level forms}, 
an @b{eval-when}
specifying the @t{:execute} situation is treated as an @i{implicit progn}
including the @i{forms} in the body of the @b{eval-when} @i{form};
otherwise, the @i{forms} in the body are ignored.

@node Processing of Defining Macros, Constraints on Macros and Compiler Macros, Processing of Top Level Forms, File Compilation
@subsubsection Processing of Defining Macros

Defining @i{macros} (such as @b{defmacro} or @b{defvar})
appearing within a file being processed by @b{compile-file}
normally have compile-time side effects which affect how subsequent @i{forms}
in the same @i{file} are compiled.  A convenient model for explaining how these
side effects happen is that the defining macro expands into one or
more @b{eval-when} @i{forms}, and that the calls which cause the compile-time
side effects to happen appear 
in the body of an @t{(eval-when (:compile-toplevel) ...)} @i{form}.

The compile-time side effects may cause information about the definition to
be stored differently than if the defining macro had been processed in the
`normal' way (either interpretively or by loading the compiled file).

In particular, the information stored by the defining @i{macros} at compile time
might or might not be available to the interpreter (either during or after compilation),
or during subsequent calls to the @i{compiler}.  For example,
the following code is nonportable because it assumes that the @i{compiler}
stores the macro definition of @t{foo} where it is available to the interpreter:

@example
 (defmacro foo (x) `(car ,x))
 (eval-when (:execute :compile-toplevel :load-toplevel)
   (print (foo '(a b c))))
@end example

A portable way to do the same thing would be to include the macro
definition inside the @b{eval-when} @i{form}, as in:

@example
 (eval-when (:execute :compile-toplevel :load-toplevel)
   (defmacro foo (x) `(car ,x))
   (print (foo '(a b c))))
@end example

Figure 3--8 lists macros that make definitions
available both in the compilation and run-time @i{environments}.
It is not specified whether definitions made available in the
@i{compilation environment} are available in the evaluation
@i{environment}, nor is it specified whether they are available
in subsequent compilation units or subsequent invocations of the
compiler.  As with @b{eval-when}, these compile-time side
effects happen only when the defining macros appear at 
top level.

@format
@group
@noindent
@w{  declaim                define-modify-macro   defsetf    }
@w{  defclass               define-setf-expander  defstruct  }
@w{  defconstant            defmacro              deftype    }
@w{  define-compiler-macro  defpackage            defvar     }
@w{  define-condition       defparameter                     }

@noindent
@w{  Figure 3--8: Defining Macros That Affect the Compile-Time Environment}

@end group
@end format

@node Constraints on Macros and Compiler Macros,  , Processing of Defining Macros, File Compilation
@subsubsection Constraints on Macros and Compiler Macros

Except where explicitly stated otherwise, no @i{macro} defined in
the @r{Common Lisp} standard produces an expansion that could cause any of the
@i{subforms} of the @i{macro form} to be treated as 
@i{top level forms}.  If an @i{implementation} also provides a
@i{special operator} definition of a @r{Common Lisp} @i{macro}, 
the @i{special operator} definition must be semantically equivalent
in this respect.

@i{Compiler macro} expansions must also have the same
top level evaluation semantics as the @i{form} which they replace.
This is of concern both to @i{conforming implementations} and to
@i{conforming programs}.

@node Literal Objects in Compiled Files, Exceptional Situations in the Compiler, File Compilation, Compilation
@subsection Literal Objects in Compiled Files

The functions @b{eval} and @b{compile} are
required to ensure that @i{literal objects} referenced within the resulting
interpreted or compiled code objects are the @i{same} as the
corresponding @i{objects} in the @i{source code}.
@b{compile-file}, on the other hand, 
must produce a @i{compiled file} that, when loaded with
@b{load}, constructs the @i{objects} defined by the
@i{source code} and produces references to them.

In the case of @b{compile-file}, @i{objects}
constructed by @b{load} of the @i{compiled file} cannot be spoken
of as being the @i{same} as the @i{objects} constructed at
compile time, because the @i{compiled file} may be loaded into a different
@i{Lisp image} than the one in which it was compiled.  This section
defines the concept of @i{similarity} which relates
@i{objects} in the @i{evaluation environment} to the
corresponding @i{objects} in the @i{run-time environment}.

The constraints on @i{literal objects} described in this section
apply only to @b{compile-file};
@b{eval} and @b{compile} do not copy or coalesce constants.

@menu
* Externalizable Objects::	
* Similarity of Literal Objects::  
* Similarity of Aggregate Objects::  
* Definition of Similarity::	
* Extensions to Similarity Rules::  
* Additional Constraints on Externalizable Objects::  
@end menu

@node Externalizable Objects, Similarity of Literal Objects, Literal Objects in Compiled Files, Literal Objects in Compiled Files
@subsubsection Externalizable Objects

The fact that the @i{file compiler} represents @i{literal} @i{objects} 
externally in a @i{compiled file} and must later reconstruct suitable 
equivalents of those @i{objects} when that @i{file} is loaded
imposes a need for constraints on the nature of the @i{objects} that can be 
used as @i{literal} @i{objects} in @i{code} to be processed 
by the @i{file compiler}.

An @i{object} that can be used as a @i{literal} @i{object} 
in @i{code} to be processed by the @i{file compiler} is called an
@i{externalizable object}
@IGindex externalizable object
.

We define that two @i{objects} are @i{similar}
@IGindex similar
 if they satisfy
a two-place conceptual equivalence predicate (defined below), which is
independent of the @i{Lisp image} so that the two @i{objects} in
different @i{Lisp images} can be understood to be equivalent under
this predicate.  Further, by inspecting the definition of this conceptual
predicate, the programmer can anticipate what aspects of an @i{object}
are reliably preserved by @i{file compilation}.

The @i{file compiler} must cooperate with the @i{loader} in order to
assure that in each case where an @i{externalizable object} is processed
as a @i{literal object}, the @i{loader} will construct a @i{similar}
@i{object}.

The set of @i{objects} that are @i{externalizable objects}
@IGindex externalizable object
 are those
for which the new conceptual term ``@i{similar}'' is defined, such that
when a @i{compiled file} is @i{loaded}, an @i{object} can be constructed
which can be shown to be @i{similar} to the original @i{object} which
existed at the time the @i{file compiler} was operating.

@node Similarity of Literal Objects, Similarity of Aggregate Objects, Externalizable Objects, Literal Objects in Compiled Files
@subsubsection Similarity of Literal Objects

@node Similarity of Aggregate Objects, Definition of Similarity, Similarity of Literal Objects, Literal Objects in Compiled Files
@subsubsection Similarity of Aggregate Objects

Of the @i{types} over which @i{similarity} is defined, 
some are treated as aggregate objects.  For these types, 
@i{similarity} is defined recursively.  
We say that an @i{object} of these types has certain ``basic qualities''
and to satisfy the @i{similarity} relationship, the values of the
corresponding qualities of the two @i{objects} must also be similar.

@node Definition of Similarity, Extensions to Similarity Rules, Similarity of Aggregate Objects, Literal Objects in Compiled Files
@subsubsection Definition of Similarity

Two @i{objects} S (in @i{source code}) and C (in @i{compiled code})
     are defined to be @i{similar} if and only if 
     they are both of one of the @i{types} listed here
      (or defined by the @i{implementation}) 
 and they both satisfy all additional requirements of @i{similarity} 
      indicated for that @i{type}.

@table @asis

@item @b{number}  
Two @i{numbers} S and C are @i{similar} if they are of the same @i{type}
and represent the same mathematical value.

@item @b{character}  
Two @i{simple} @i{characters} S and C are @i{similar} 
if they have @i{similar} @i{code} @i{attributes}.

@i{Implementations} providing additional, @i{implementation-defined} 
@i{attributes} must define whether and how @i{non-simple} @i{characters} 
can be regarded as @i{similar}.

@item @b{symbol}  
Two @i{apparently uninterned} @i{symbols} S and C are @i{similar}
if their
@i{names}
are @i{similar}.

Two @i{interned} symbols S and C are @i{similar} 
if their @i{names} are @i{similar},
and if either S is accessible in the @i{current package} at compile time
          and C is accessible in the @i{current package} at load time,
       or C is accessible in the @i{package} that is @i{similar} to
          the @i{home package} of S.

(Note that @i{similarity} of
@i{symbols} is dependent
on neither the @i{current readtable} nor how the @i{function} @b{read} would
parse the @i{characters} in the @i{name} of the @i{symbol}.)

@item @b{package}  
Two @i{packages} S and C are @i{similar} if their @i{names} are @i{similar}.

Note that although a @i{package} @i{object} is an @i{externalizable object},
the programmer is responsible for ensuring that the corresponding @i{package} is
already in existence when code referencing it as a @i{literal} @i{object} 
is @i{loaded}.  The @i{loader} finds the corresponding @i{package} @i{object}
as if by calling @b{find-package} with that @i{name} as an @i{argument}.
An error is signaled by the @i{loader} if no @i{package} exists at load time.

@item @b{random-state}  
Two @i{random states} S and C are @i{similar} if S
would always produce the same sequence of pseudo-random numbers 
as a @i{copy}_5 of C
when given as the @i{random-state} @i{argument} to the @i{function} @b{random}, 
assuming equivalent @i{limit} @i{arguments} in each case.

(Note that since C has been processed by the @i{file compiler},
it cannot be used directly as an @i{argument} to @b{random}
because @b{random} would perform a side effect.)

@item @b{cons}  
Two @i{conses}, S and C, are @i{similar} if
    the @i{car}_2 of S is @i{similar} to the @i{car}_2 of C,
and the @i{cdr}_2 of S is @i{similar} to the @i{cdr}_2 of C.

@item @b{array}  
Two one-dimensional @i{arrays}, S and C, are @i{similar} if
     the @i{length} of S is @i{similar} to the @i{length} of C,
     the @i{actual array element type} of S is @i{similar} to
     the @i{actual array element type} of C,
 and each @i{active} @i{element} of S is @i{similar} to
      the corresponding @i{element} of C.

Two @i{arrays} of @i{rank} other than one, S and C, are @i{similar} if
     the @i{rank} of S is @i{similar} to the @i{rank} of C,
     each @i{dimension}_1 of S is @i{similar} to 
      the corresponding @i{dimension}_1 of C,
     the @i{actual array element type} of S is @i{similar} to
     the @i{actual array element type} of C,
 and each @i{element} of S is @i{similar} to
      the corresponding @i{element} of C.

In addition,
if S is a @i{simple array}, then C must also be a @i{simple array}.
If S is a @i{displaced array},
       has a @i{fill pointer},
    or is @i{actually adjustable}, 
C is permitted to lack any or all of these qualities.

@item @b{hash-table}  
Two @i{hash tables} S and C are @i{similar} if they meet the following
three requirements:

@table @asis

@item 1.  
They both have the same test 
 	    (@i{e.g.}, they are both @b{eql} @i{hash tables}).

@item 2.  
There is a unique one-to-one correspondence between the keys of
           the two @i{hash tables}, such that the corresponding keys are 
	   @i{similar}.

@item 3.  
For all keys, the values associated with two corresponding keys
           are @i{similar}.
@end table

If there is more than one possible one-to-one correspondence between
the keys of S and C, the consequences are unspecified.  
A @i{conforming program} cannot use a table such as S as an
@i{externalizable constant}.

@item @b{pathname}  
Two @i{pathnames} S and C are @i{similar} if all corresponding 
@i{pathname components} are @i{similar}.

@item @b{function}  

@i{Functions} are not @i{externalizable objects}.

@item @b{structure-object} and @b{standard-object}  

A general-purpose concept of @i{similarity} does not exist for @i{structures}
and @i{standard objects}.
However, a @i{conforming program} is permitted to define a @b{make-load-form}
@i{method} for any @i{class} K defined by that @i{program} that is
a @i{subclass} of either @b{structure-object} or @b{standard-object}.
The effect of such a @i{method} is to define that an @i{object} S of @i{type} K
in @i{source code} is @i{similar} to an @i{object} C of @i{type} K
in @i{compiled code} if C was constructed from @i{code} produced by 
calling @b{make-load-form} on S.

@end table

@node Extensions to Similarity Rules, Additional Constraints on Externalizable Objects, Definition of Similarity, Literal Objects in Compiled Files
@subsubsection Extensions to Similarity Rules

Some @i{objects}, such as @i{streams}, @b{readtables}, and @b{methods}
are not @i{externalizable objects} under the definition of similarity given above.
That is, such @i{objects} may not portably appear as @i{literal} @i{objects} 
in @i{code} to be processed by the @i{file compiler}. 

An @i{implementation} is permitted to extend the rules of similarity, 
so that other kinds of @i{objects} are @i{externalizable objects}
for that @i{implementation}.

If for some kind of @i{object}, @i{similarity} is
neither defined by this specification 
	    nor by the @i{implementation}, 
then the @i{file compiler} must signal an error upon encountering such 
an @i{object} as a @i{literal constant}.

@node Additional Constraints on Externalizable Objects,  , Extensions to Similarity Rules, Literal Objects in Compiled Files
@subsubsection Additional Constraints on Externalizable Objects

If two @i{literal objects} appearing in the source code for a single file
processed with
the @i{file compiler} 
are the @i{identical},
the corresponding @i{objects} in the @i{compiled code} 
must also be the @i{identical}.

With the exception of @i{symbols} and @i{packages}, any two
@i{literal objects}
in @i{code} being processed by
the @i{file compiler}
may be @i{coalesced} 
if and only if they are @i{similar}; 
if they are either both @i{symbols} or both @i{packages},
they may only be @i{coalesced} if and only if they are @i{identical}.

@i{Objects} containing circular references can 
be @i{externalizable objects}.
The @i{file compiler} is required to preserve @b{eql}ness of 
substructures within a @i{file}.
Preserving @b{eql}ness means that subobjects that are
the @i{same}
in the @i{source code} must 
be
the @i{same}
in the corresponding @i{compiled code}.

In addition, the following are constraints on the handling of
@i{literal objects} by the @i{file compiler}:

@table @asis

@item @t{}  
@b{array:} If an @i{array} in the source code is a
@i{simple array}, then the corresponding @i{array}
in the compiled code will also be a @i{simple array}.  If
an @i{array} in the source code is displaced, has a 
@i{fill pointer}, or is @i{actually adjustable}, the corresponding 
@i{array} in the compiled code might lack any or all of these
qualities. If an @i{array} in the source code has a fill
pointer, then the corresponding @i{array} in the compiled
code might be only the size implied by the fill pointer.

@item @t{}  
@b{packages:} The loader is required to find the
corresponding @i{package} @i{object} as if by calling 
@b{find-package} with the package name as an argument.  
An error of @i{type} @b{package-error} is signaled if no 
@i{package} of that name exists at load time.

@item @t{}  
@b{random-state:} A constant @i{random state}
object cannot be used as the state argument 
to the @i{function} @b{random} because @b{random} modifies this data structure.

@item @t{}  
@b{structure, standard-object:}
@i{Objects} of @i{type} @b{structure-object} and @b{standard-object}
may appear in compiled constants if there is an
appropriate @b{make-load-form} method defined for that
@i{type}.

The @i{file compiler} calls @b{make-load-form} on any @i{object}
that is referenced as a @i{literal object} if the @i{object} is a
@i{generalized instance} of @b{standard-object},
@b{structure-object}, @b{condition}, or any of a 
(possibly empty) @i{implementation-dependent} set of other @i{classes}.
The @i{file compiler} only calls @b{make-load-form} once for
any given @i{object} within a single @i{file}.

@item @t{}  
@b{symbol:} In order to guarantee that @i{compiled files} can be @i{loaded}
  correctly, users must ensure that the @i{packages} referenced in those @i{files}
  are defined consistently at compile time and load time.  @i{Conforming programs}
  must satisfy the following requirements:

@table @asis

@item 1.  
The @i{current package} when a @i{top level form} in the @i{file}
      is processed by @b{compile-file} must be the same as the @i{current package}
      when the @i{code} corresponding to that @i{top level form} in the
      @i{compiled file} is executed by @b{load}.  In particular:

@table @asis

@item a.  
Any @i{top level form} in a @i{file} that alters
	  the @i{current package} must change it to a @i{package}
	  of the same @i{name} both at compile time and at load time.

@item b.  
If the first @i{non-atomic} @i{top level form} in the @i{file}
	  is not an @b{in-package} @i{form}, then the @i{current package}
	  at the time @b{load} is called must be a @i{package} with the 
	  same @i{name} as the package that was the @i{current package}
	  at the time @b{compile-file} was called.
@end table

@item 2.  
For all @i{symbols} 
      appearing lexically within a @i{top level form} that
      were @i{accessible} in the @i{package} that was the @i{current package}
      during processing of that @i{top level form} at compile time, but
      whose @i{home package} was another @i{package}, at load time there must
      be a @i{symbol} with the same @i{name} that is @i{accessible} in both the
      load-time @i{current package} and in the @i{package}
      with the same @i{name} as the
      compile-time @i{home package}. 

@item 3.  
For all @i{symbols} represented in the @i{compiled file} 
      that were @i{external symbols} in
      their @i{home package} at compile time, there must be a @i{symbol} with the
      same @i{name} that is an @i{external symbol} in the @i{package} 
      with the same @i{name} at load time.
@end table

  If any of these conditions do not hold, the @i{package} in which the @i{loader} looks
  for the affected @i{symbols} is unspecified.  @i{Implementations} are permitted 
  to signal an error or to define this behavior.

@end table

@node Exceptional Situations in the Compiler,  , Literal Objects in Compiled Files, Compilation
@subsection Exceptional Situations in the Compiler

@b{compile} and @b{compile-file} are permitted to
signal errors and warnings, including errors due to compile-time
processing of @t{(eval-when (:compile-toplevel) ...)} forms,
macro expansion, and conditions signaled by the compiler itself.

@i{Conditions} of @i{type} @b{error} might be signaled by the compiler
in situations where the compilation cannot proceed without intervention.  

In addition to situations for which the standard specifies that
@i{conditions} of @i{type} @b{warning} must or might be signaled,
warnings might be signaled in situations where the compiler can
determine that the consequences are undefined or that a run-time
error will be signaled.  Examples of this situation are as follows: 
    violating type declarations,
    altering or assigning the value of a constant defined with @b{defconstant},
    calling built-in Lisp functions with a wrong number of arguments or malformed keyword
      argument lists, 
and using unrecognized declaration specifiers.

The compiler is permitted to issue warnings about matters of
programming style as conditions of @i{type} @b{style-warning}.
Examples of this situation are as follows:
      redefining a function using a different argument list,
      calling a function with a wrong number of arguments,
      not declaring @b{ignore} of a local variable that is not referenced,
  and referencing a variable declared @b{ignore}.

Both @b{compile} and @b{compile-file} are permitted
(but not required) to @i{establish} a @i{handler}
for @i{conditions} of @i{type} @b{error}.  For example, they
might signal a warning, and restart compilation from some
@i{implementation-dependent} point in order to let the 
compilation proceed without manual intervention.

Both @b{compile} and @b{compile-file} return three
values, the second two indicating whether the source code being compiled
contained errors and whether style warnings were issued.

Some warnings might be deferred until the end of compilation. 
See @b{with-compilation-unit}.

@c end of including concept-compile

@node Declarations, Lambda Lists, Compilation, Evaluation and Compilation
@section Declarations

@c including concept-decls

@i{Declarations}
@IGindex declaration
 provide a way of specifying information for use by
program processors, such as the evaluator or the compiler.

@i{Local declarations}
@IGindex local declaration

can be embedded in executable code using @b{declare}.
@i{Global declarations}
@IGindex global declaration
, 
or @i{proclamations}
@IGindex proclamation
,
are established by @b{proclaim} or @b{declaim}.

The @b{the} @i{special form} provides a shorthand notation for 
making a @i{local declaration} about the @i{type} of the
@i{value} of a given @i{form}.

The consequences are undefined if a program violates a @i{declaration}
or a @i{proclamation}.

@menu
* Minimal Declaration Processing Requirements::	 
* Declaration Specifiers::	
* Declaration Identifiers::	
* Declaration Scope::		
@end menu

@node Minimal Declaration Processing Requirements, Declaration Specifiers, Declarations, Declarations
@subsection Minimal Declaration Processing Requirements

In general, an @i{implementation} is free to ignore
@i{declaration specifiers} except for the
     @b{declaration}
@IRindex declaration
,
     @b{notinline}
@IRindex notinline
,
     @b{safety}
@IRindex safety
,
 and @b{special}
@IRindex special
 @i{declaration specifiers}.

A @b{declaration} @i{declaration} must suppress warnings
about unrecognized @i{declarations} of the kind that it declares.
If an @i{implementation} does not produce warnings about
unrecognized declarations, it may safely ignore this @i{declaration}.

A @b{notinline} @i{declaration} must be recognized by any @i{implementation}
that supports inline functions or @i{compiler macros} in order to disable those facilities.
An @i{implementation} that does not use inline functions or @i{compiler macros}
may safely ignore this @i{declaration}.

A @b{safety} @i{declaration} that increases the current safety level 
must always be recognized.  An @i{implementation} that always processes 
code as if safety were high may safely ignore this @i{declaration}.

A @b{special} @i{declaration} must be processed by all @i{implementations}.

@node Declaration Specifiers, Declaration Identifiers, Minimal Declaration Processing Requirements, Declarations
@subsection Declaration Specifiers

A @i{declaration specifier}
@IGindex declaration specifier
 is an @i{expression} that can appear at
top level of a @b{declare} expression or a @b{declaim} form, or as 
the argument to @b{proclaim}.
It is a @i{list} whose @i{car} is a @i{declaration identifier},
and whose @i{cdr} is data interpreted according to rules specific to
the @i{declaration identifier}.

@node Declaration Identifiers, Declaration Scope, Declaration Specifiers, Declarations
@subsection Declaration Identifiers

Figure 3--9 shows a list of all 
@i{declaration identifiers}
@IGindex declaration identifier

defined by this standard.

@format
@group
@noindent
@w{  declaration     ignore     special  }
@w{  dynamic-extent  inline     type     }
@w{  ftype           notinline           }
@w{  ignorable       optimize            }

@noindent
@w{  Figure 3--9: Common Lisp Declaration Identifiers}

@end group
@end format

An implementation is free to support other (@i{implementation-defined})
@i{declaration identifiers} as well.  
A warning might be issued
if a @i{declaration identifier} 
is not among those defined above,
is not defined by the @i{implementation},
is not a @i{type} @i{name}, 
and has not been declared in a @b{declaration} @i{proclamation}.

@menu
* Shorthand notation for Type Declarations::  
@end menu

@node Shorthand notation for Type Declarations,  , Declaration Identifiers, Declaration Identifiers
@subsubsection Shorthand notation for Type Declarations

A @i{type specifier} can be used as a @i{declaration identifier}.
@t{(@i{type-specifier} @{@i{var}@}*)} is taken as shorthand for
@t{(type @i{type-specifier} @{@i{var}@}*)}.

@node Declaration Scope,  , Declaration Identifiers, Declarations
@subsection Declaration Scope

@i{Declarations} can be divided into two kinds: those that apply to the
@i{bindings} of @i{variables} or @i{functions}; and those that
do not apply to @i{bindings}.

A @i{declaration} that appears at the head of a binding @i{form} 
and applies to a @i{variable} or @i{function} @i{binding} 
made by that @i{form} is called a @i{bound declaration}
@IGindex bound declaration
; 
such a @i{declaration} affects both the @i{binding} and
any references within the @i{scope} of the @i{declaration}.  

@i{Declarations} that are not @i{bound declarations} are called
@i{free declarations}
@IGindex free declaration
.

A @i{free declaration} in a @i{form} F1 that applies to a @i{binding}
for a @i{name} N @i{established} by some @i{form} F2
of which F1 is a @i{subform}
affects only references to N within F1; it does not to apply to
other references to N outside of F1, nor does it affect the manner
in which the @i{binding} of N by F2 is @i{established}.

@i{Declarations} that do not apply to @i{bindings} can only appear 
as @i{free declarations}.

The @i{scope} of a @i{bound declaration} is the same as the
@i{lexical scope}
of the @i{binding} to which it applies;
for @i{special variables},
this means the @i{scope} that the @i{binding} 
would have had had it been a @i{lexical binding}.

Unless explicitly stated otherwise, the @i{scope} of a 
@i{free declaration} includes only the body @i{subforms} of 
the @i{form} at whose head it appears, and no other @i{subforms}.
The @i{scope} of @i{free declarations} specifically does not
include @i{initialization forms} for @i{bindings} established
by the @i{form} containing the @i{declarations}.

Some @i{iteration forms} include step, end-test, or result 
@i{subforms} that are also included in the @i{scope}
of @i{declarations} that appear in the @i{iteration form}.
Specifically, the @i{iteration forms} and @i{subforms} involved
are:

@table @asis

@item @t{*}  
@b{do}, @b{do*}:  
  @i{step-forms}, @i{end-test-form}, and @i{result-forms}.
@item @t{*}  
@b{dolist}, @b{dotimes}:
  @i{result-form}
@item @t{*}  
@b{do-all-symbols}, @b{do-external-symbols}, @b{do-symbols}:
  @i{result-form}
@end table

@menu
* Examples of Declaration Scope::  
@end menu

@node Examples of Declaration Scope,  , Declaration Scope, Declaration Scope
@subsubsection Examples of Declaration Scope

Here is an example illustrating the @i{scope} of @i{bound declarations}.

@example
 (let ((x 1))                ;[1] 1st occurrence of x
   (declare (special x))     ;[2] 2nd occurrence of x
   (let ((x 2))              ;[3] 3rd occurrence of x
     (let ((old-x x)         ;[4] 4th occurrence of x
           (x 3))            ;[5] 5th occurrence of x
       (declare (special x)) ;[6] 6th occurrence of x
       (list old-x x))))     ;[7] 7th occurrence of x
@result{}  (2 3)
@end example

The first occurrence of @t{x} @i{establishes} a @i{dynamic binding}
of @t{x} because of the @b{special} @i{declaration} for @t{x}
in the second line.  The third occurrence of @t{x} @i{establishes} a
@i{lexical binding} of @t{x} (because there is no @b{special}
@i{declaration} in the corresponding @b{let} @i{form}).
The fourth occurrence of @t{x} @i{x} is a reference to the
@i{lexical binding} of @t{x} established in the third line.
The fifth occurrence of @t{x} @i{establishes} a @i{dynamic binding}
of @i{x} for the body of the @b{let} @i{form} that begins on
that line because of the @b{special} @i{declaration} for @t{x}
in the sixth line. The reference to @t{x} in the fourth line is not
affected by the @b{special} @i{declaration} in the sixth line 
because that reference is not within the ``would-be @i{lexical scope}''
of the @i{variable} @t{x} in the fifth line.  The reference to @t{x}
in the seventh line is a reference to the @i{dynamic binding} of @i{x}
@i{established} in the fifth line.

Here is another example, to illustrate the @i{scope} of a
@i{free declaration}.  In the following:

@example
 (lambda (&optional (x (foo 1))) ;[1]
   (declare (notinline foo))     ;[2]
   (foo x))                      ;[3]
@end example

the @i{call} to @t{foo} in the first line might be 
compiled inline even though the @i{call} to @t{foo} in
the third line must not be.  This is because
the @b{notinline} @i{declaration}
for @t{foo} in the second line applies only to the body on the
third line.  In order to suppress inlining for both @i{calls}, 
one might write:

@example
 (locally (declare (notinline foo)) ;[1]
   (lambda (&optional (x (foo 1)))  ;[2]
     (foo x)))                      ;[3]
@end example

or, alternatively:

@example
 (lambda (&optional                               ;[1]
            (x (locally (declare (notinline foo)) ;[2]
                 (foo 1))))                       ;[3]
   (declare (notinline foo))                      ;[4]
   (foo x))                                       ;[5]
@end example

Finally, here is an example that shows the @i{scope} of
@i{declarations} in an @i{iteration form}.

@example
 (let ((x  1))                     ;[1]
   (declare (special x))           ;[2]
     (let ((x 2))                  ;[3]
       (dotimes (i x x)            ;[4]
         (declare (special x)))))  ;[5]
@result{}  1
@end example

In this example, the first reference to @t{x} on the fourth line is to
the @i{lexical binding} of @t{x} established on the third line.
However, the second occurrence of @t{x} on the fourth line lies within
the @i{scope} of the @i{free declaration} on the fifth line
(because this is the @i{result-form} of the @b{dotimes})
and therefore refers to the @i{dynamic binding} of @t{x}.

@c end of including concept-decls

@node Lambda Lists, Error Checking in Function Calls, Declarations, Evaluation and Compilation
@section Lambda Lists

@c including concept-bvl

A @i{lambda list}
@IGindex lambda list
 is a @i{list} that
specifies a set of @i{parameters} (sometimes called @i{lambda variables})
and a protocol for receiving @i{values} for those @i{parameters}.

There are several kinds of @i{lambda lists}.

@format
@group
@noindent
@w{ Context                                     Kind of Lambda List                             }
@w{ @b{defun} @i{form}                                  @i{ordinary lambda list}                            }
@w{ @b{defmacro} @i{form}                               @i{macro lambda list}                               }
@w{ @i{lambda expression}                           @i{ordinary lambda list}                            }
@w{ @b{flet} local @i{function} definition              @i{ordinary lambda list}                            }
@w{ @b{labels} local @i{function} definition            @i{ordinary lambda list}                            }
@w{ @b{handler-case} @i{clause} specification           @i{ordinary lambda list}                            }
@w{ @b{restart-case} @i{clause} specification           @i{ordinary lambda list}                            }
@w{ @b{macrolet} local @i{macro} definition             @i{macro lambda list}                               }
@w{ @b{define-method-combination}                   @i{ordinary lambda list}                            }
@w{ @b{define-method-combination} @t{:arguments} option @i{define-method-combination arguments lambda list} }
@w{ @b{defstruct} @t{:constructor} option               @i{boa lambda list}                                 }
@w{ @b{defgeneric} @i{form}                             @i{generic function lambda list}                    }
@w{ @b{defgeneric} @i{method} clause                    @i{specialized lambda list}                         }
@w{ @b{defmethod} @i{form}                              @i{specialized lambda list}                         }
@w{ @b{defsetf} @i{form}                                @i{defsetf lambda list}                             }
@w{ @b{define-setf-expander} @i{form}                   @i{macro lambda list}                               }
@w{ @b{deftype} @i{form}                                @i{deftype lambda list}                             }
@w{ @b{destructuring-bind} @i{form}                     @i{destructuring lambda list}                       }
@w{ @b{define-compiler-macro} @i{form}                  @i{macro lambda list}                               }
@w{ @b{define-modify-macro} @i{form}                    @i{define-modify-macro lambda list}                 }

@noindent
@w{                         Figure 3--10: What Kind of Lambda Lists to Use                       }

@end group
@end format

Figure 3--11 lists some @i{defined names} that are applicable
to @i{lambda lists}.

@format
@group
@noindent
@w{  lambda-list-keywords  lambda-parameters-limit    }

@noindent
@w{  Figure 3--11: Defined names applicable to lambda lists}

@end group
@end format

@menu
* Ordinary Lambda Lists::	
* Generic Function Lambda Lists::  
* Specialized Lambda Lists::	
* Macro Lambda Lists::		
* Destructuring Lambda Lists::	
* Boa Lambda Lists::		
* Defsetf Lambda Lists::	
* Deftype Lambda Lists::	
* Define-modify-macro Lambda Lists::  
* Define-method-combination Arguments Lambda Lists::  
* Syntactic Interaction of Documentation Strings and Declarations::  
@end menu

@node Ordinary Lambda Lists, Generic Function Lambda Lists, Lambda Lists, Lambda Lists
@subsection Ordinary Lambda Lists

An @i{ordinary lambda list}
@IGindex ordinary lambda list
 is used to describe how a set of
@i{arguments} is received by an @i{ordinary} @i{function}.  
The @i{defined names} in Figure 3--12 are those which use
@i{ordinary lambda lists}:

@format
@group
@noindent
@w{  define-method-combination  handler-case  restart-case  }
@w{  defun                      labels                      }
@w{  flet                       lambda                      }

@noindent
@w{  Figure 3--12: Standardized Operators that use Ordinary Lambda Lists}

@end group
@end format

An @i{ordinary lambda list} can contain the @i{lambda list keywords} shown
in Figure 3--13.

@format
@group
@noindent
@w{  @b{&allow-other-keys}  @b{&key}       @b{&rest}  }
@w{  @b{&aux}               @b{&optional}         }

@noindent
@w{  Figure 3--13: Lambda List Keywords used by Ordinary Lambda Lists}

@end group
@end format

Each @i{element} of a @i{lambda list} is either a parameter specifier
or a @i{lambda list keyword}.
Implementations are free to provide additional @i{lambda list keywords}.
For a list of all @i{lambda list keywords}
used by the implementation, see @b{lambda-list-keywords}.

The syntax for @i{ordinary lambda lists} is as follows: 

@w{@i{lambda-list} ::=@r{(}@{@i{var}@}*}
@w{                 @t{[}@r{&optional} @{@i{var} |
		       @r{(}@i{var} @r{[}init-form @r{[}supplied-p-parameter @r{]}@r{]}@r{)}@}*@t{]}}
@w{                 @t{[}@r{&rest} @i{var}@t{]}}
@w{                 @t{[}@r{&key} @{@i{var} |
		          	 @r{(}@{@i{var} | 
					       @r{(}@i{keyword-name} @i{var}@r{)}@}
				 	@r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}* pt @r{[}@t{&allow-other-keys}@r{]}@t{]}}
@w{                 @t{[}@r{&aux} @{@i{var} | @r{(}@i{var} @r{[}@i{init-form}@r{]}@r{)}@}*@t{]}@r{)}}
@w{               }

A @i{var} or @i{supplied-p-parameter} must be a @i{symbol}
that is not the name of a @i{constant variable}.

An @i{init-form} can be any @i{form}.
Whenever any @i{init-form} is evaluated for any parameter
specifier, that @i{form} may refer to any parameter variable to
the left of the specifier in which the @i{init-form} appears,
including any @i{supplied-p-parameter} variables, and may rely 
on the fact that no other parameter variable has yet been bound
(including its own parameter variable).

A @i{keyword-name} can be any @i{symbol}, 
but by convention is normally a @i{keyword}_1;
all @i{standardized} @i{functions} follow that convention.

An @i{ordinary lambda list} has five parts, any or all of which may be empty.
For information about the treatment of argument mismatches,
see @ref{Error Checking in Function Calls}.

@menu
* Specifiers for the required parameters::  
* Specifiers for optional parameters::	
* A specifier for a rest parameter::  
* Specifiers for keyword parameters::  
* Suppressing Keyword Argument Checking::  
* Examples of Suppressing Keyword Argument Checking::  
* Specifiers for @b{&aux} variables::  
* Examples of Ordinary Lambda Lists::  
@end menu

@node Specifiers for the required parameters, Specifiers for optional parameters, Ordinary Lambda Lists, Ordinary Lambda Lists
@subsubsection Specifiers for the required parameters

These are all the parameter specifiers up to 
the first @i{lambda list keyword};
if there are no @i{lambda list keywords}, 
then all the specifiers are for required parameters.
Each required parameter is specified by a parameter variable @i{var}.
@i{var} is bound as a lexical variable unless it is declared @b{special}.

If there are @t{n} required parameters (@t{n} may be zero), 
there must be at least @t{n} passed arguments, and the 
required parameters are bound to the first @t{n} passed arguments;
see @ref{Error Checking in Function Calls}.
The other parameters are then processed using any remaining arguments.

@node Specifiers for optional parameters, A specifier for a rest parameter, Specifiers for the required parameters, Ordinary Lambda Lists
@subsubsection Specifiers for optional parameters

@IRindex &optional

If @b{&optional} is present,
the optional parameter specifiers are those following 
@b{&optional} 
up to the next @i{lambda list keyword} or the end of the list.
If optional parameters are specified, then each one is processed as
follows.  If any unprocessed arguments remain, then the parameter variable
@i{var} is bound to the next remaining argument, just as for a required
parameter.  If no arguments remain, however, then @i{init-form} 
is evaluated, and the parameter variable
is bound to the resulting value 
(or to @b{nil} if no @i{init-form} appears
in the parameter specifier).
If another variable name @i{supplied-p-parameter} 
appears in the specifier, it is bound
to @i{true} if an argument had been available, and to @i{false} if no
argument remained (and therefore @i{init-form} had to be evaluated).
@i{Supplied-p-parameter}
is bound not to an argument but to a value indicating whether or not
an argument had been supplied for the corresponding @i{var}.

@node A specifier for a rest parameter, Specifiers for keyword parameters, Specifiers for optional parameters, Ordinary Lambda Lists
@subsubsection A specifier for a rest parameter

@IRindex &rest

@b{&rest}, if present, must be followed by a single @i{rest parameter}
specifier, which in turn must be followed by another 
@i{lambda list keyword} or the end of the @i{lambda list}.  After all
optional parameter specifiers have been processed, then there may or
may not be a @i{rest parameter}.  If there is a @i{rest parameter}, it is
bound to a @i{list} of all as-yet-unprocessed arguments.  If
no unprocessed arguments remain, the @i{rest parameter} is bound to the
@i{empty list}.  If there is no @i{rest parameter} and there are no 
@i{keyword parameters}, then an error 
should be signaled if
any unprocessed arguments remain; see @ref{Error Checking in Function Calls}.
The value of a @i{rest parameter}
is permitted, but not required, to share structure with the
last argument to @b{apply}.

@IRindex &key

@IRindex &allow-other-keys

@node Specifiers for keyword parameters, Suppressing Keyword Argument Checking, A specifier for a rest parameter, Ordinary Lambda Lists
@subsubsection Specifiers for keyword parameters

If @b{&key} 
is present, all specifiers up to the next @i{lambda list keyword}
or the end of the @i{list} are keyword parameter specifiers.
When keyword parameters are processed,
the same arguments are processed that
would be made into a @i{list} for a @i{rest parameter}.
It is permitted to specify both @b{&rest} and @b{&key}.
In this case the remaining arguments are used for both purposes;
that is, all remaining arguments are made into a @i{list} for the
@i{rest parameter}, and are also processed for the @b{&key} parameters.

If @b{&key} is specified, there must remain
an even number of arguments; see @ref{Odd Number of Keyword Arguments}.

These arguments are considered as pairs,
the first argument in each pair being interpreted as a name
and the second as the corresponding value.
The first @i{object} of each pair must be a @i{symbol};
see @ref{Invalid Keyword Arguments}.
The keyword parameter specifiers may optionally be followed by the
@i{lambda list keyword} @b{&allow-other-keys}.

In each keyword parameter specifier must be a name @i{var} for
the parameter variable.

If the @i{var} appears alone or in a @t{(@i{var} @i{init-form})}
combination, the keyword name used when matching @i{arguments} to @i{parameters}
is a @i{symbol} in the @t{KEYWORD} @i{package} whose @i{name} is the
@i{same} (under @b{string=}) as @i{var}'s.
If the notation @t{((@i{keyword-name} @i{var}) @i{init-form})} is used,
then the keyword name used to match @i{arguments} to @i{parameters} is
@i{keyword-name}, which may be a @i{symbol} in any @i{package}.
(Of course, if it is not a @i{symbol} in the @t{KEYWORD} @i{package},
it does not necessarily self-evaluate, so care must be taken when calling the function
to make sure that normal evaluation still yields the keyword name.)

Thus

@example
 (defun foo (&key radix (type 'integer)) ...)
@end example

means exactly the same as

@example
 (defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)
@end example

The keyword parameter specifiers are, like all parameter specifiers,
effectively processed from left to right.  For each keyword parameter
specifier, if there is an argument pair whose name matches that
specifier's name (that is, the names are @b{eq}), then the
parameter variable for that specifier is bound to the second item (the
value) of that argument pair.  If more than one such argument pair
matches, the leftmost argument pair is used.  If no such argument pair
exists, then the @i{init-form} for that specifier is evaluated and
the parameter variable is bound to that value (or to @b{nil} if no
@i{init-form} was specified).  @i{supplied-p-parameter} is
treated as for @b{&optional} parameters: it is bound to @i{true} if there
was a matching argument pair, and to @i{false} otherwise.

Unless keyword argument checking is suppressed,
an argument pair must a name matched by a parameter specifier;
see @ref{Unrecognized Keyword Arguments}.

If keyword argument checking is suppressed, 
then it is permitted for an argument pair
to match no parameter specifier, and the argument pair is ignored, but
such an argument pair is accessible through the @i{rest parameter} if
one was supplied.  The purpose of these mechanisms is to allow sharing
of argument lists among several @i{lambda expressions} and to
allow either the caller or the called @i{lambda expression} to
specify that such sharing may be taking place.

Note that if @b{&key} is present, a keyword argument of @t{:allow-other-keys}
is always permitted---regardless of whether the associated value is @i{true}
or @i{false}.  However, if the value is @i{false}, other non-matching
keywords are not tolerated (unless @b{&allow-other-keys} was used).

Furthermore, if the receiving argument list specifies a regular argument which
would be flagged by @t{:allow-other-keys}, then @t{:allow-other-keys} has both
its special-cased meaning (identifying whether additional keywords are permitted)
and its normal meaning (data flow into the function in question).

@node Suppressing Keyword Argument Checking, Examples of Suppressing Keyword Argument Checking, Specifiers for keyword parameters, Ordinary Lambda Lists
@subsubsection Suppressing Keyword Argument Checking

If @b{&allow-other-keys} was specified in the @i{lambda list} of a @i{function},
@i{keyword}_2 @i{argument} checking is suppressed in calls
to that @i{function}.

If the @t{:allow-other-keys} @i{argument} is @i{true} in a call to a @i{function},
@i{keyword}_2 @i{argument} checking is suppressed 
in that call.

The @t{:allow-other-keys} @i{argument} is permissible in all situations involving
@i{keyword}_2 @i{arguments}, even when its associated @i{value}
is @i{false}.

@node Examples of Suppressing Keyword Argument Checking, Specifiers for @b{&aux} variables, Suppressing Keyword Argument Checking, Ordinary Lambda Lists
@subsubsection Examples of Suppressing Keyword Argument Checking

@example
;;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.
 ((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) @result{}  1
;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.
 ((lambda (&key x &allow-other-keys) x) :x 1 :y 2) @result{}  1
;;; :ALLOW-OTHER-KEYS NIL is always permitted.
 ((lambda (&key) t) :allow-other-keys nil) @result{}  T
;;; As with other keyword arguments, only the left-most pair
;;; named :ALLOW-OTHER-KEYS has any effect.
 ((lambda (&key x) x) 
  :x 1 :y 2 :allow-other-keys t :allow-other-keys nil)
@result{}  1
;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,
;;; so in safe code this signals a PROGRAM-ERROR (and might enter the
;;; debugger).  In unsafe code, the consequences are undefined.
 ((lambda (&key x) x)                   ;This call is not valid
  :x 1 :y 2 :allow-other-keys nil :allow-other-keys t)
@end example

@node Specifiers for @b{&aux} variables, Examples of Ordinary Lambda Lists, Examples of Suppressing Keyword Argument Checking, Ordinary Lambda Lists
@subsubsection Specifiers for @b{&aux} variables

@IRindex &aux

These are not really parameters.  If the @i{lambda list keyword}
@b{&aux} is present, all specifiers after it are auxiliary variable
specifiers.  After all parameter specifiers have been processed, the
auxiliary variable specifiers (those following @b{&aux}) are processed
from left to right.  For each one, @i{init-form} is evaluated and
@i{var} is bound to that value (or to @b{nil} if no @i{init-form}
was specified).  @b{&aux} variable processing is analogous to
@b{let*} processing.

@example
 (lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))
    @equiv{} (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))
@end example

@node Examples of Ordinary Lambda Lists,  , Specifiers for @b{&aux} variables, Ordinary Lambda Lists
@subsubsection Examples of Ordinary Lambda Lists

Here are some examples involving @i{optional parameters} and @i{rest parameters}:

@example
 ((lambda (a b) (+ a (* b 3))) 4 5) @result{}  19
 ((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) @result{}  19
 ((lambda (a &optional (b 2)) (+ a (* b 3))) 4) @result{}  10
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))
@result{}  (2 NIL 3 NIL NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)
@result{}  (6 T 3 NIL NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)
@result{}  (6 T 3 T NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)
@result{}  (6 T 3 T (8))
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))
  6 3 8 9 10 11)
@result{}  (6 t 3 t (8 9 10 11))
@end example

Here are some examples involving @i{keyword parameters}:

@example
 ((lambda (a b &key c d) (list a b c d)) 1 2) @result{}  (1 2 NIL NIL)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) @result{}  (1 2 6 NIL)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) @result{}  (1 2 NIL 8)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) @result{}  (1 2 6 8)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) @result{}  (1 2 6 8)
 ((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) @result{}  (:a 1 6 8)
 ((lambda (a b &key c d) (list a b c d)) :a :b :c :d) @result{}  (:a :b :d NIL)
 ((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) @result{}  (1 2 6 NIL)
 ((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) @result{}  (1 2 6 NIL)
@end example

Here are some examples involving @i{optional parameters}, @i{rest parameters},
and @i{keyword parameters} together:

@example
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1)   
@result{}  (1 3 NIL 1 ()) 
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 2)
@result{}  (1 2 NIL 1 ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) :c 7)
@result{}  (:c 7 NIL :c ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :c 7)
@result{}  (1 6 7 1 (:c 7))
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :d 8)
@result{}  (1 6 NIL 8 (:d 8))
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :d 8 :c 9 :d 10)
@result{}  (1 6 9 8 (:d 8 :c 9 :d 10))
@end example

As an example of the use of @b{&allow-other-keys} and
@t{:allow-other-keys}, consider a @i{function} that takes two named
arguments of its own and also accepts additional named arguments to be
passed to @b{make-array}:

@example
 (defun array-of-strings (str dims &rest named-pairs
                          &key (start 0) end &allow-other-keys)
   (apply #'make-array dims
          :initial-element (subseq str start end)
          :allow-other-keys t
          named-pairs))
@end example

This @i{function} takes a @i{string} and dimensioning
information and returns an @i{array} of the specified
dimensions, each of whose elements is the specified 
@i{string}.  However, @t{:start} and @t{:end} named
arguments may be used to specify that a substring of the given
@i{string} should be used.  In addition, the presence of
@b{&allow-other-keys} in the @i{lambda list} indicates that the
caller may supply additional named arguments; the @i{rest parameter}
provides access to them.  These additional named arguments are passed
to @b{make-array}.  The @i{function} @b{make-array}
normally does not allow the named arguments @t{:start} 
and @t{:end} to be used, and an error should be
signaled if such named arguments are supplied to @b{make-array}.
However, the presence in the call to @b{make-array} 
of the named argument @t{:allow-other-keys} with
a @i{true} value causes any extraneous named arguments, including
@t{:start} and @t{:end}, to be acceptable and ignored.

@node Generic Function Lambda Lists, Specialized Lambda Lists, Ordinary Lambda Lists, Lambda Lists
@subsection Generic Function Lambda Lists

A @i{generic function lambda list}
@IGindex generic function lambda list
 is used to describe the overall shape of
the argument list to be accepted by a @i{generic function}.
Individual @i{method} @i{signatures} might contribute additional 
@i{keyword parameters} to the @i{lambda list} of the @i{effective method}.

A @i{generic function lambda list} is used by @b{defgeneric}.

A @i{generic function lambda list} has the following syntax:

@w{@i{lambda-list} ::=@r{(}@{@i{var}@}*}
@w{                 @t{[}@r{&optional} @{@i{var} | @r{(}@i{var}@r{)}@}*@t{]}}
@w{                 @t{[}@r{&rest} @i{var}@t{]}}
@w{                 @t{[}@r{&key} @{@i{var} | @r{(}@{@i{var} | 
					       @r{(}@i{keyword-name} @i{var}@r{)}@}@r{)}@}* pt @r{[}@t{&allow-other-keys}@r{]}@t{]}@r{)}}
@w{               }

A @i{generic function lambda list} can contain the @i{lambda list keywords} shown
in Figure 3--14.

@format
@group
@noindent
@w{  @b{&allow-other-keys}  @b{&optional}    }
@w{  @b{&key}               @b{&rest}        }

@noindent
@w{  Figure 3--14: Lambda List Keywords used by Generic Function Lambda Lists}

@end group
@end format

A @i{generic function lambda list} differs from an @i{ordinary lambda list} 
in the following ways:

@table @asis

@item Required arguments  
Zero or more @i{required parameters} must be specified.

@item Optional and keyword arguments  
@i{Optional parameters} and @i{keyword parameters} may not have 
default initial value forms nor use supplied-p parameters.

@item Use of @b{&aux}  
The use of @b{&aux} is not allowed. 
@end table

@node Specialized Lambda Lists, Macro Lambda Lists, Generic Function Lambda Lists, Lambda Lists
@subsection Specialized Lambda Lists

A @i{specialized lambda list}
@IGindex specialized lambda list
 is used to @i{specialize} a @i{method}
for a particular @i{signature} and to describe how @i{arguments} matching
that @i{signature} are received by the @i{method}.  
The @i{defined names} in Figure 3--15 use @i{specialized lambda lists}
in some way; see the dictionary entry for each for information about how.

@format
@group
@noindent
@w{  defmethod  defgeneric    }

@noindent
@w{  Figure 3--15: Standardized Operators that use Specialized Lambda Lists}

@end group
@end format

A @i{specialized lambda list} can contain the @i{lambda list keywords} shown
in Figure 3--16.

@format
@group
@noindent
@w{  @b{&allow-other-keys}  @b{&key}       @b{&rest}  }
@w{  @b{&aux}               @b{&optional}         }

@noindent
@w{  Figure 3--16: Lambda List Keywords used by Specialized Lambda Lists}

@end group
@end format

A @i{specialized lambda list} is syntactically the same as an @i{ordinary lambda list}
except that each @i{required parameter} may optionally be associated with a @i{class}
or @i{object} for which that @i{parameter} is @i{specialized}.

@w{@i{lambda-list} ::=@r{(}@{@i{var} | @r{(}@i{var} @r{[}@i{specializer}@r{]}@r{)}@}*}
@w{                @t{[}@r{&optional} @{@i{var} |
		       @r{(}@i{var} @r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}*@t{]}}
@w{                @t{[}@r{&rest} @i{var}@t{]}}
@w{                @t{[}@r{&key} @{@i{var} |
		          	 @r{(}@{@i{var} | 
					       @r{(}@i{keyword-name} @i{var}@r{)}@}
				 	@r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}* @r{[}@t{&allow-other-keys}@r{]}@t{]}}
@w{                @t{[}@r{&aux} @{@i{var} | @r{(}@i{var} @r{[}@i{init-form}@r{]}@r{)}@}*@t{]}@r{)}}
@w{               }

@node Macro Lambda Lists, Destructuring Lambda Lists, Specialized Lambda Lists, Lambda Lists
@subsection Macro Lambda Lists

A @i{macro lambda list}
@IGindex macro lambda list
 is used in describing @i{macros} 
defined by the @i{operators} in Figure 3--17.

@format
@group
@noindent
@w{  define-compiler-macro  defmacro  macrolet  }
@w{  define-setf-expander                       }

@noindent
@w{  Figure 3--17: Operators that use Macro Lambda Lists}

@end group
@end format

With the additional restriction that
an @i{environment parameter} may appear only once
(at any of the positions indicated),
a @i{macro lambda list} has the following syntax:


@w{@i{reqvars} ::=@{@i{var} | !@i{pattern}@}*}

@w{@i{optvars} ::=@t{[}@r{&optional} @{@i{var} |
		       @r{(}@r{@{@i{var} | !@i{pattern}@}} @r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}*@t{]}}

@w{@i{restvar} ::=@t{[}@{@t{&rest} | @r{&body}@} @i{@{@i{var} | !@i{pattern}@}}@t{]}}

@w{@i{keyvars} ::=@r{[}@r{&key} @{@i{var} |
		          	 @r{(}@{@i{var} | 
					       @r{(}@i{keyword-name} @{@i{var} | !@i{pattern}@}@r{)}@}
				 	@r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}*}
@w{            @r{[}@t{&allow-other-keys}@r{]}@r{]}}


@w{@i{auxvars} ::=@t{[}@r{&aux} @{@i{var} | @r{(}@r{@i{var}} @r{[}@i{init-form}@r{]}@r{)}@}*@t{]}}

@w{@i{envvar} ::=@t{[}@r{&environment} @i{var}@t{]}}

@w{@i{wholevar} ::=@t{[}@r{&whole} @i{var}@t{]}}

@w{@i{lambda-list} ::=@r{(}!@i{wholevar} !@i{envvar} !@i{reqvars} !@i{envvar} !@i{optvars} !@i{envvar}}
@w{                !@i{restvar} !@i{envvar} !@i{keyvars} !@i{envvar} !@i{auxvars} !@i{envvar}@r{)} |}
@w{                @r{(}!@i{wholevar} !@i{envvar} !@i{reqvars} !@i{envvar} !@i{optvars} !@i{envvar} @t{.} @i{var}@r{)}}

@w{@i{pattern} ::=@r{(}!@i{wholevar} !@i{reqvars} !@i{optvars} !@i{restvar} !@i{keyvars} !@i{auxvars}@r{)} |}
@w{            @r{(}!@i{wholevar} !@i{reqvars} !@i{optvars} @t{.} @i{var}@r{)}}



A @i{macro lambda list} can contain
the @i{lambda list keywords} shown in Figure 3--18.

@format
@group
@noindent
@w{  @b{&allow-other-keys}  @b{&environment}  @b{&rest}   }
@w{  @b{&aux}               @b{&key}          @b{&whole}  }
@w{  @b{&body}              @b{&optional}             }

@noindent
@w{  Figure 3--18: Lambda List Keywords used by Macro Lambda Lists}

@end group
@end format

@i{Optional parameters} (introduced by @b{&optional}) and
@i{keyword parameters} (introduced by @b{&key})
can be supplied in a @i{macro lambda list},
just as in an @i{ordinary lambda list}.
Both may contain default initialization forms and @i{supplied-p parameters}.

@b{&body}
@IRindex &body

is identical in function to @b{&rest},
but it can be used to inform certain output-formatting 
and editing functions that the remainder of the @i{form} is
treated as a body, and should be indented accordingly.
Only one of @b{&body} or @b{&rest} can be used at any particular level; 
see @ref{Destructuring by Lambda Lists}.

@b{&body} can appear at any level of a 
@i{macro lambda list}; 
for details, see @ref{Destructuring by Lambda Lists}.

@b{&whole}
@IRindex &whole

is followed by a single variable that is bound to the
entire macro-call form; this is the value that the @i{macro function}
receives as its first argument.

If @b{&whole} and a following variable appear,
they must appear first in @i{lambda-list},

before any other parameter or @i{lambda list keyword}.

@b{&whole} can appear at any level of a @i{macro lambda list}. 
At inner levels, the @b{&whole} variable is bound to
		the corresponding part of the argument, 
as with @b{&rest}, but unlike @b{&rest}, other arguments are also allowed.
The use of @b{&whole} does not affect the pattern of arguments
     specified.

@b{&environment}
@IRindex &environment

is followed by a single variable that is bound
to an @i{environment} representing the @i{lexical environment} in which the
macro call is to be interpreted.
This @i{environment} 
should be used with

@b{macro-function},

@b{get-setf-expansion},

@b{compiler-macro-function}, 

and
@b{macroexpand} 
(for example) in computing the expansion of the macro, to ensure that any
@i{lexical bindings} or definitions established in the 
@i{compilation environment} are taken into account.

@b{&environment} can only appear at the top level of a
	@i{macro lambda list}, and can only
appear once, but can appear anywhere in that list;

the @b{&environment} @i{parameter} is @i{bound} along with @b{&whole}
before any other @i{variables} in the @i{lambda list}, regardless of where
@b{&environment} appears in the @i{lambda list}.

The @i{object} that is bound to the
@i{environment parameter} has @i{dynamic extent}.

Destructuring allows a @i{macro lambda list} to express
the structure of a macro call syntax.
If no @i{lambda list keywords} appear,
then the @i{macro lambda list} is a @i{tree}
containing parameter names at the leaves.
The pattern and the @i{macro form} must have compatible @i{tree structure}; 
that is, their @i{tree structure} must be equivalent,
or it must differ only in that some @i{leaves} of the pattern
match @i{non-atomic} @i{objects} of the @i{macro form}.

For information about error detection in this @i{situation},
see @ref{Destructuring Mismatch}.

A destructuring @i{lambda list}
(whether at top level or embedded) 
can
be dotted, ending
in a parameter name.  This situation is treated exactly as if the
parameter name that ends the @i{list} had appeared preceded by @b{&rest}.

It is permissible for a @i{macro} @i{form} (or a @i{subexpression} of a
@i{macro} @i{form})
to be a @i{dotted list} 
only  when @t{(... &rest var)} or @t{(... . var)} is used to match
 it. It is the responsibility of the @i{macro} to recognize and deal
 with such situations.

[Editorial Note by KMP: Apparently the dotted-macro-forms cleanup doesn't allow for
		 the macro to `manually' notice dotted forms and fix them as well.
		 It shouldn't be required that this be done only by &REST or 
		 a dotted pattern; it should only matter that ultimately the 
		 non-macro result of a full-macro expansion not contain dots.
		 Anyway, I plan to address this editorially unless someone
		 raises an objection.]

@menu
* Destructuring by Lambda Lists::  
* Data-directed Destructuring by Lambda Lists::	 
* Examples of Data-directed Destructuring by Lambda Lists::  
* Lambda-list-directed Destructuring by Lambda Lists::	
@end menu

@node Destructuring by Lambda Lists, Data-directed Destructuring by Lambda Lists, Macro Lambda Lists, Macro Lambda Lists
@subsubsection Destructuring by Lambda Lists

Anywhere in a @i{macro lambda list} where a parameter
name can appear, and where @i{ordinary lambda list} syntax
(as described in @ref{Ordinary Lambda Lists}) does not 
otherwise allow a @i{list}, a @i{destructuring lambda list} 
can appear in place
of the parameter name.  When this is done, then the argument 
that would match the parameter is treated as a (possibly dotted) @i{list},
to be used as an argument list for satisfying the
parameters in the embedded @i{lambda list}.
This is known as destructuring.

Destructuring is the process of decomposing a compound @i{object} into
its component parts, using an abbreviated, declarative syntax, rather
than writing it out by hand using the primitive component-accessing
functions.  Each component part is bound to a variable.

A destructuring operation requires an @i{object} to be decomposed, 
a pattern that specifies what components are to be extracted, and the names
of the variables whose values are to be the components.

@node Data-directed Destructuring by Lambda Lists, Examples of Data-directed Destructuring by Lambda Lists, Destructuring by Lambda Lists, Macro Lambda Lists
@subsubsection Data-directed Destructuring by Lambda Lists

In data-directed destructuring,
the pattern is a sample @i{object} of the @i{type} to be decomposed.
Wherever a component is to be extracted, 
a @i{symbol} appears in the pattern; 
this @i{symbol} is the name of the variable whose value will be that component.

@node Examples of Data-directed Destructuring by Lambda Lists, Lambda-list-directed Destructuring by Lambda Lists, Data-directed Destructuring by Lambda Lists, Macro Lambda Lists
@subsubsection Examples of Data-directed Destructuring by Lambda Lists

An example pattern is

@t{(a b c)}

which destructures a list of three elements.  The variable @t{a} is assigned
to the first element, @t{b} to the second, etc.  A more complex example
is

@t{((first . rest) . more)}

The important features of data-directed destructuring are its syntactic
simplicity and the ability to extend it to lambda-list-directed destructuring.

@node Lambda-list-directed Destructuring by Lambda Lists,  , Examples of Data-directed Destructuring by Lambda Lists, Macro Lambda Lists
@subsubsection Lambda-list-directed Destructuring by Lambda Lists

An extension of data-directed destructuring of @i{trees} is
lambda-list-directed destructuring.  This derives from the analogy
between the three-element destructuring pattern

@t{(first second third)}

and the three-argument @i{lambda list}

@t{(first second third)}

Lambda-list-directed destructuring is identical to data-directed destructuring
if no @i{lambda list keywords} appear in the pattern.  
Any list in the pattern (whether a sub-list or the whole pattern itself)
that contains a @i{lambda list keyword} is interpreted specially.
Elements of the list to the left of the first
@i{lambda list keyword} are treated as destructuring patterns, as usual, but the
remaining elements of the list are treated like a function's 
@i{lambda list}
except that where a variable would normally be required, an arbitrary
destructuring pattern is allowed.  Note that in case of ambiguity,
@i{lambda list} syntax is preferred over destructuring syntax.  Thus, after
@b{&optional} a list of elements is a list of a destructuring pattern
and a default value form.

The detailed behavior of each @i{lambda list keyword} in a 
lambda-list-directed destructuring
pattern is as follows:

@table @asis

@item @b{&optional}  
Each following element is a variable or a list of a destructuring
pattern, a default value form, and a supplied-p variable.  The default value and
the supplied-p variable can be omitted.  
If the list being destructured ends
early, so that it does not have an element to match against this destructuring
(sub)-pattern, the default form is evaluated and destructured instead.  The
supplied-p variable receives the value 
@b{nil} if the default form is used, @b{t} otherwise.

@item @b{&rest}, @b{&body}  
The next element is a destructuring pattern that matches the
rest of the list.  @b{&body} is identical to @b{&rest} but declares that what
is being matched is a list of forms that constitutes the body of @i{form}.
This next element must be the last unless a @i{lambda list keyword} follows it.

@item @b{&aux}  
The remaining elements are not destructuring patterns at all, but are
auxiliary variable bindings.  

@item @b{&whole}  
The next element is a destructuring pattern that matches the entire
form in a macro, or the entire @i{subexpression} at inner levels.

@item @b{&key}  
Each following element is one of
@table @asis

@item @t{}  
a @i{variable},

@item or  
a list of a variable,
           an optional initialization form,
       and an optional supplied-p variable.

@item or  
a list of a list of a keyword and a destructuring pattern,
           an optional initialization form,
       and an optional supplied-p variable.
@end table

The rest of the list being destructured
is taken to be alternating keywords and values and is taken apart appropriately.

@item @b{&allow-other-keys}  
Stands by itself.
@end table

@node Destructuring Lambda Lists, Boa Lambda Lists, Macro Lambda Lists, Lambda Lists
@subsection Destructuring Lambda Lists

A @i{destructuring lambda list}
@IGindex destructuring lambda list
 is used by @b{destructuring-bind}.

@i{Destructuring lambda lists} are closely related to 
@i{macro lambda lists}; see @ref{Macro Lambda Lists}.
A @i{destructuring lambda list} can contain all of the
@i{lambda list keywords} listed for @i{macro lambda lists}
except for @b{&environment}, and supports destructuring in the
same way.  Inner @i{lambda lists} nested within a @i{macro lambda list}
have the syntax of @i{destructuring lambda lists}.

A @i{destructuring lambda list} has the following syntax:


@w{@i{reqvars} ::=@{@i{var} | !@i{lambda-list}@}*}

@w{@i{optvars} ::=@t{[}@r{&optional} @{@i{var} |
		       @r{(}@{@i{var} | !@i{lambda-list}@} @r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}*@t{]}}

@w{@i{restvar} ::=@t{[}@{@t{&rest}} | @t{&body}@} @i{@{@i{var} | !@i{lambda-list}@}@t{]}}

@w{@i{keyvars} ::=@r{[}@r{&key} @{@i{var} |
		          	 @r{(}@{@i{var} | 
					       @r{(}@i{keyword-name} @{@i{var} | !@i{lambda-list}@}@r{)}@}
				 	@r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}*}
@w{            @r{[}@t{&allow-other-keys}@r{]}@r{]}}


@w{@i{auxvars} ::=@t{[}@r{&aux} @{@i{var} | @r{(}@i{var} @r{[}@i{init-form}@r{]}@r{)}@}*@t{]}}

@w{@i{envvar} ::=@t{[}@r{&environment} @i{var}@t{]}}

@w{@i{wholevar} ::=@t{[}@r{&whole} @i{var}@t{]}}

@w{@i{lambda-list} ::=@r{(}!@i{wholevar} !@i{reqvars} !@i{optvars} !@i{restvar} !@i{keyvars} !@i{auxvars}@r{)} |}
@w{                @r{(}!@i{wholevar} !@i{reqvars} !@i{optvars} @t{.} @i{var}@r{)}}


@node Boa Lambda Lists, Defsetf Lambda Lists, Destructuring Lambda Lists, Lambda Lists
@subsection Boa Lambda Lists

A @i{boa lambda list}
@IGindex boa lambda list
 is a @i{lambda list} that is syntactically 
like an @i{ordinary lambda list}, but that is processed in
``@b{b}y @b{o}rder of @b{a}rgument'' style.

A @i{boa lambda list} is used only in a @b{defstruct} @i{form},
when explicitly specifying the @i{lambda list} 
of a constructor @i{function} (sometimes called a ``boa constructor'').

The @b{&optional}, @b{&rest}, @b{&aux},

@b{&key}, and @b{&allow-other-keys}

@i{lambda list keywords} are recognized in a @i{boa lambda list}.
The way these @i{lambda list keywords} differ from their
use in an @i{ordinary lambda list} follows.

Consider this example, which describes how @b{destruct} processes
its @t{:constructor} option.

@example
 (:constructor create-foo
         (a &optional b (c 'sea) &rest d &aux e (f 'eff)))
@end example

This defines @t{create-foo} to be a constructor of one or more arguments.
The first argument is used to initialize the @t{a} slot.  The second
argument is used to initialize the @t{b} slot.  If there isn't any
second argument, then the default value given in the body of the
@b{defstruct} (if given) is used instead.  
The third argument is used to
initialize the @t{c} slot.  If there isn't any third argument, then the
symbol @t{sea} is used instead.  Any arguments following the third
argument are collected into a @i{list} 
and used to initialize the @t{d}
slot.  If there are three or fewer arguments, then @b{nil} is placed in
the @t{d} slot.  The @t{e} slot is not initialized; 
its initial value is @i{implementation-defined}.
Finally, the @t{f} slot is initialized to contain the symbol @t{eff}.

@b{&key} and @b{&allow-other-keys} arguments default
in a manner similar to that of @b{&optional} arguments: if no default
is supplied in the @i{lambda list} then the default value 
given in the body of the @b{defstruct} (if given) is used instead.
For example:

@example
 (defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)
                                             &key (d 2)
                                             &aux e (f 'eff))))
   (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))

 (create-foo 10) @result{}  #S(FOO A 10 B 2 C SEA D 2 E @i{implemention-dependent} F EFF)
 (create-foo 10 'bee 'see :d 'dee) 
@result{}  #S(FOO A 10 B BEE C SEE D DEE E @i{implemention-dependent} F EFF)
@end example

If keyword arguments of the form 
@t{((@i{key} @i{var}) @r{[}@i{default} @r{[}@i{svar}@r{]}@r{]})}
are specified, the @i{slot} @i{name} is matched with @i{var} 
(not @i{key}).

The actions taken in the @t{b} and @t{e} cases were carefully
chosen to allow the user to specify all possible behaviors. 
The @b{&aux} variables can be used to completely override the default
initializations given in the body.

If no default value is supplied for an @i{aux variable} variable,
the consequences are undefined if an attempt is later made to read
the corresponding @i{slot}'s value before a value is explicitly assigned.
If such a @i{slot} has a @t{:type} option specified,
this suppressed initialization does not imply a type mismatch situation;
the declared type is only required to apply when the @i{slot} is finally assigned.

With this definition, the following can be written:

@example
 (create-foo 1 2)
@end example

instead of

@example
 (make-foo :a 1 :b 2)
@end example

and @t{create-foo} provides defaulting different
from that of @t{make-foo}.

Additional arguments that do not correspond to slot names but
are merely present to supply values used in subsequent initialization 
computations are allowed.
For example, in the definition

@example
 (defstruct (frob (:constructor create-frob
                  (a &key (b 3 have-b) (c-token 'c) 
                          (c (list c-token (if have-b 7 2))))))
         a b c)
@end example

the @t{c-token} argument is used merely to supply a value used in the 
initialization of the @t{c} slot. The @i{supplied-p parameters} 
associated with @i{optional parameters} and @i{keyword parameters}
might also be used this way.

@node Defsetf Lambda Lists, Deftype Lambda Lists, Boa Lambda Lists, Lambda Lists
@subsection Defsetf Lambda Lists

A @i{defsetf lambda list}
@IGindex defsetf lambda list
 is used by @b{defsetf}.

A @i{defsetf lambda list} has the following syntax:

@w{@i{lambda-list} ::=@r{(}@{@i{var}@}*}
@w{                @t{[}@r{&optional} @{@i{var} |
		       @r{(}@i{var} @r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}*@t{]}}
@w{                @t{[}@r{&rest} @i{var}@t{]}}
@w{                @t{[}@r{&key} @{@i{var} |
		          	 @r{(}@{@i{var} | 
					       @r{(}@i{keyword-name} @i{var}@r{)}@}
				 	@r{[}init-form @r{[}supplied-p-parameter@r{]}@r{]}@r{)}@}* pt @r{[}@t{&allow-other-keys}@r{]}@t{]}}
@w{                @t{[}@r{&environment} @i{var}@t{]}}

A @i{defsetf lambda list} can contain the @i{lambda list keywords} shown
in Figure 3--19.

@format
@group
@noindent
@w{  @b{&allow-other-keys}  @b{&key}       @b{&rest}  }
@w{  @b{&environment}       @b{&optional}         }

@noindent
@w{  Figure 3--19: Lambda List Keywords used by Defsetf Lambda Lists}

@end group
@end format

A @i{defsetf lambda list} differs from an @i{ordinary lambda list} 
only in that it does not permit the use of @b{&aux}, 
and that it permits use of @b{&environment}, 
     which introduces an @i{environment parameter}.

@node Deftype Lambda Lists, Define-modify-macro Lambda Lists, Defsetf Lambda Lists, Lambda Lists
@subsection Deftype Lambda Lists

A @i{deftype lambda list}
@IGindex deftype lambda list
 is used by @b{deftype}.

A @i{deftype lambda list} has the same syntax as a @i{macro lambda list},
and can therefore contain the @i{lambda list keywords} as a @i{macro lambda list}.

A @i{deftype lambda list} differs from a @i{macro lambda list} 
only in that if no @i{init-form} is supplied for an @i{optional parameter}
or @i{keyword parameter} in the @i{lambda-list}, the default @i{value} 
for that @i{parameter} is the @i{symbol} @b{*} (rather than @b{nil}).

@node Define-modify-macro Lambda Lists, Define-method-combination Arguments Lambda Lists, Deftype Lambda Lists, Lambda Lists
@subsection Define-modify-macro Lambda Lists

A @i{define-modify-macro lambda list}
@IGindex define-modify-macro lambda list
 is used by 
@b{define-modify-macro}.

A @i{define-modify-macro lambda list} can contain the 
@i{lambda list keywords} shown in Figure 3--20.

@format
@group
@noindent
@w{  @b{&optional}  @b{&rest}  }

@noindent
@w{  Figure 3--20: Lambda List Keywords used by Define-modify-macro Lambda Lists}

@end group
@end format

@i{Define-modify-macro lambda lists} are similar to 
@i{ordinary lambda lists}, but do not support keyword arguments.
@b{define-modify-macro} has no need match keyword arguments, and
a @i{rest parameter} is sufficient.  @i{Aux variables} are also
not supported, since @b{define-modify-macro} has no body @i{forms}
which could refer to such @i{bindings}.  See the @i{macro} @b{define-modify-macro}.

@node Define-method-combination Arguments Lambda Lists, Syntactic Interaction of Documentation Strings and Declarations, Define-modify-macro Lambda Lists, Lambda Lists
@subsection Define-method-combination Arguments Lambda Lists

A @i{define-method-combination arguments lambda list}
@IGindex define-method-combination arguments lambda list
 is used by 
the @t{:arguments} option to @b{define-method-combination}.

A @i{define-method-combination arguments lambda list} can contain the 
@i{lambda list keywords} shown in Figure 3--21.

@format
@group
@noindent
@w{  @b{&allow-other-keys}  @b{&key}       @b{&rest}   }
@w{  @b{&aux}               @b{&optional}  @b{&whole}  }

@noindent
@w{  Figure 3--21: Lambda List Keywords used by Define-method-combination arguments Lambda Lists}

@end group
@end format

@i{Define-method-combination arguments lambda lists} are similar to 
@i{ordinary lambda lists}, but also permit the use of @b{&whole}.

@node Syntactic Interaction of Documentation Strings and Declarations,  , Define-method-combination Arguments Lambda Lists, Lambda Lists
@subsection Syntactic Interaction of Documentation Strings and Declarations

In a number of situations, a @i{documentation string} can appear amidst a
series of @b{declare} @i{expressions} prior to a series of @i{forms}.

In that case, if a @i{string} S appears where a @i{documentation string} is
permissible and is not followed by 
  either a @b{declare} @i{expression} 
      or a @i{form}
then S is taken to be a @i{form};
otherwise, S is taken as a @i{documentation string}.
The consequences are unspecified if more than one such @i{documentation string} 
is present.

@c end of including concept-bvl

@node Error Checking in Function Calls, Traversal Rules and Side Effects, Lambda Lists, Evaluation and Compilation
@section Error Checking in Function Calls

@c including concept-args

@menu
* Argument Mismatch Detection::	 
@end menu

@node Argument Mismatch Detection,  , Error Checking in Function Calls, Error Checking in Function Calls
@subsection Argument Mismatch Detection

@menu
* Safe and Unsafe Calls::	
* Error Detection Time in Safe Calls::	
* Too Few Arguments::		
* Too Many Arguments::		
* Unrecognized Keyword Arguments::  
* Invalid Keyword Arguments::	
* Odd Number of Keyword Arguments::  
* Destructuring Mismatch::	
* Errors When Calling a Next Method::  
@end menu

@node Safe and Unsafe Calls, Error Detection Time in Safe Calls, Argument Mismatch Detection, Argument Mismatch Detection
@subsubsection Safe and Unsafe Calls

A @i{call} is a @i{safe call}
@IGindex safe call
 if each of the following is
either @i{safe} @i{code} or @i{system code} (other than
@i{system code} that results from @i{macro expansion} of 
@i{programmer code}):
@table @asis

@item @t{*}  
the @i{call}.
@item @t{*}  
the definition of the @i{function} being @i{called}.
@item @t{*}  
the point of @i{functional evaluation} 
@end table

The following special cases require some elaboration:

@table @asis

@item @t{*}  
If the @i{function} being called is a @i{generic function},
it is considered @i{safe} if all of the following are

@i{safe code} or @i{system code}:

@table @asis

@item --  
its definition (if it was defined explicitly).
@item --  
the @i{method} definitions for all @i{applicable} @i{methods}.
@item --  
the definition of its @i{method combination}.
@end table

@item @t{*}  
For the form @t{(coerce @i{x} 'function)}, 
where @i{x} is a @i{lambda expression},
the value of the @i{optimize quality} @b{safety}
in the global environment at the time the @b{coerce}
is @i{executed} applies to the resulting @i{function}.

@item @t{*}  
For a call to the @i{function} @b{ensure-generic-function}, the value of the
@i{optimize quality} @b{safety} in the @i{environment}
@i{object} passed as the @t{:environment} @i{argument} applies 
to the resulting @i{generic function}.

@item @t{*}  
For a call to @b{compile} with a @i{lambda expression} as the
@i{argument}, the value of the @i{optimize quality} @b{safety}
in the @i{global environment} at the time @b{compile} is @i{called}
applies to the resulting @i{compiled function}.

@item @t{*}  
For a call to @b{compile} with only one argument, if the original definition
of the @i{function} was @i{safe}, then the resulting @i{compiled function}
must also be @i{safe}.

@item @t{*}  
A @i{call} to a @i{method} by @b{call-next-method} must be 
considered @i{safe} if each of the following is 

@i{safe code} or @i{system code}:

@table @asis

@item --  
the definition of the @i{generic function} (if it was defined explicitly).
@item --  
the @i{method} definitions for all @i{applicable} @i{methods}.
@item --  
the definition of the @i{method combination}.
@item --  
the point of entry into the body of the @i{method defining form},
	      where the @i{binding} of @b{call-next-method} is established.
@item --  
the point of @i{functional evaluation} of the name @b{call-next-method}.
@end table

@end table

An @i{unsafe call}
@IGindex unsafe call
 is a @i{call} that is not a @i{safe call}.

The informal intent is that the @i{programmer} can rely on a @i{call}
to be @i{safe}, even when @i{system code} is involved, if all reasonable
steps have been taken to ensure that the @i{call} is @i{safe}.
For example, if a @i{programmer} calls @b{mapcar} from @i{safe}
@i{code} and supplies a @i{function} that was @i{compiled} 
as @i{safe}, the @i{implementation} is required to ensure that
@b{mapcar} makes a @i{safe call} as well.

@node Error Detection Time in Safe Calls, Too Few Arguments, Safe and Unsafe Calls, Argument Mismatch Detection
@subsubsection Error Detection Time in Safe Calls

If an error is signaled in a @i{safe call},
the exact point of the @i{signal} is @i{implementation-dependent}.
In particular, it might be signaled at compile time or at run time,
and if signaled at run time, 
it might be prior to, during, or after @i{executing} the @i{call}.
However, it is always prior to the execution of the body of the @i{function} 
being @i{called}.

@node Too Few Arguments, Too Many Arguments, Error Detection Time in Safe Calls, Argument Mismatch Detection
@subsubsection Too Few Arguments

It is not permitted to supply too few @i{arguments} to a @i{function}.
Too few arguments means fewer @i{arguments} than the number of @i{required parameters} 
for the @i{function}.

If this @i{situation} occurs in a @i{safe call},

an error of @i{type} @b{program-error} must be signaled;
and in an @i{unsafe call} the @i{situation} has undefined consequences.

@node Too Many Arguments, Unrecognized Keyword Arguments, Too Few Arguments, Argument Mismatch Detection
@subsubsection Too Many Arguments

It is not permitted to supply too many @i{arguments} to a @i{function}.
Too many arguments means more @i{arguments} than the number of @i{required parameters}
plus the number of @i{optional parameters}; however, if the @i{function} 
uses @b{&rest} or @b{&key}, it is not possible for it to receive too many arguments.

If this @i{situation} occurs in a @i{safe call},

an error of @i{type} @b{program-error} must be signaled;
and in an @i{unsafe call} the @i{situation} has undefined consequences.

@node Unrecognized Keyword Arguments, Invalid Keyword Arguments, Too Many Arguments, Argument Mismatch Detection
@subsubsection Unrecognized Keyword Arguments

It is not permitted to supply a keyword argument to a @i{function}
using a name that is not recognized by that @i{function} 
unless keyword argument checking is suppressed as described
in @ref{Suppressing Keyword Argument Checking}.

If this @i{situation} occurs in a @i{safe call},

an error of @i{type} @b{program-error} must be signaled;
and in an @i{unsafe call} the @i{situation} has undefined consequences.

@node Invalid Keyword Arguments, Odd Number of Keyword Arguments, Unrecognized Keyword Arguments, Argument Mismatch Detection
@subsubsection Invalid Keyword Arguments

It is not permitted to supply a keyword argument to a @i{function}
using a name that is not a @i{symbol}.

If this @i{situation} occurs in a @i{safe call},

an error of @i{type} @b{program-error} must be signaled 
unless keyword argument checking is suppressed as described
in @ref{Suppressing Keyword Argument Checking};
and in an @i{unsafe call} the @i{situation} has undefined consequences.

@node Odd Number of Keyword Arguments, Destructuring Mismatch, Invalid Keyword Arguments, Argument Mismatch Detection
@subsubsection Odd Number of Keyword Arguments

An odd number of @i{arguments} must not be supplied for the @i{keyword parameters}.

If this @i{situation} occurs in a @i{safe call},

an error of @i{type} @b{program-error} must be signaled
unless keyword argument checking is suppressed as described
in @ref{Suppressing Keyword Argument Checking};
and in an @i{unsafe call} the @i{situation} has undefined consequences.

@node Destructuring Mismatch, Errors When Calling a Next Method, Odd Number of Keyword Arguments, Argument Mismatch Detection
@subsubsection Destructuring Mismatch

When matching a @i{destructuring lambda list} against a @i{form},
the pattern and the @i{form} must have compatible @i{tree structure},
as described in @ref{Macro Lambda Lists}.

Otherwise, in a @i{safe call},
an error of @i{type} @b{program-error} must be signaled;
and in an @i{unsafe call} the @i{situation} has undefined consequences.

@node Errors When Calling a Next Method,  , Destructuring Mismatch, Argument Mismatch Detection
@subsubsection Errors When Calling a Next Method

If @b{call-next-method} is called with @i{arguments}, the ordered
set of @i{applicable} @i{methods} for the changed set of @i{arguments}
for @b{call-next-method} must be the same as the ordered set of 
@i{applicable} @i{methods} for the original @i{arguments} to the
@i{generic function}, or else an error should be signaled.

The comparison between the set of methods applicable to the
new arguments and the set applicable to the original arguments is
insensitive to order differences among methods with the same
specializers.

If @b{call-next-method} is called with @i{arguments} that specify
a different ordered set of @i{applicable} methods and there is no 
@i{next method} available, the test for different methods and the 
associated error signaling (when present) takes precedence over calling
@b{no-next-method}.

@c end of including concept-args

@node Traversal Rules and Side Effects, Destructive Operations, Error Checking in Function Calls, Evaluation and Compilation
@section Traversal Rules and Side Effects

@c including concept-traversal

The consequences are undefined 
when @i{code} executed during an @i{object-traversing} operation
destructively modifies the @i{object} in a way that might affect the
ongoing traversal operation.
In particular, the following rules apply.
@table @asis

@item @b{List traversal}  
For @i{list} traversal operations, the @i{cdr} chain of the
 @i{list} is not allowed to be destructively modified.

@item @b{Array traversal}  
For @i{array} traversal operations, the @i{array} is not allowed 
  to be adjusted and its @i{fill pointer}, if any, is not allowed to 
  be changed.

@item @b{Hash-table traversal}  
For @i{hash table} traversal operations, new elements may not be added
  or deleted except that the element corresponding to the current hash key 
  may be changed or removed.

@item @b{Package traversal}  
For @i{package} traversal operations (@i{e.g.}, @b{do-symbols}),
  new @i{symbols} may not be @i{interned} in or @i{uninterned} 
  from the @i{package} being traversed 
  or any @i{package} that it uses except that the 
  current @i{symbol} may be @i{uninterned} from the @i{package} 
  being traversed.

@end table

@c end of including concept-traversal

@node Destructive Operations, Evaluation and Compilation Dictionary, Traversal Rules and Side Effects, Evaluation and Compilation
@section Destructive Operations

@c including concept-destruction

@menu
* Modification of Literal Objects::  
* Transfer of Control during a Destructive Operation::	
@end menu

@node Modification of Literal Objects, Transfer of Control during a Destructive Operation, Destructive Operations, Destructive Operations
@subsection Modification of Literal Objects

The consequences are undefined if @i{literal} @i{objects} 
are destructively modified.  For this purpose, the following operations 
are considered @i{destructive}:

@table @asis

@item @b{random-state}  
Using it as an @i{argument} to the @i{function} @b{random}.

@item @b{cons}  
Changing the @i{car}_1 or @i{cdr}_1 of the @i{cons},
or performing a @i{destructive} operation on an @i{object} which is either
the @i{car}_2 or the @i{cdr}_2 of the @i{cons}.

@item @b{array}  
Storing a new value into some element of the @i{array},
or performing a @i{destructive} operation 
on an @i{object} that is already such an @i{element}.

Changing the @i{fill pointer}, @i{dimensions}, or displacement of
the @i{array} (regardless of whether the @i{array} is @i{actually adjustable}).

Performing a @i{destructive} operation on another @i{array} 
that is displaced to the @i{array} or that otherwise shares its contents
with the @i{array}.

@item @b{hash-table}  
Performing a @i{destructive} operation on any @i{key}.

Storing a new @i{value}_4 for any @i{key},
or performing a @i{destructive} operation 
on any @i{object} that is such a @i{value}.

Adding or removing entries from the @i{hash table}.

@item @b{structure-object}  
Storing a new value into any slot,
or performing a @i{destructive} operation on an @i{object} 
that is the value of some slot.

@item @b{standard-object}  
Storing a new value into any slot,
or performing a @i{destructive} operation on an @i{object} 
that is the value of some slot.

Changing the class of the @i{object} (@i{e.g.}, using the @i{function} @b{change-class}).

@item @b{readtable}  
Altering the @i{readtable case}.

Altering the syntax type of any character in this readtable.

Altering the @i{reader macro function} associated with any @i{character}
in the @i{readtable}, or altering the @i{reader macro functions}
associated with @i{characters} defined as @i{dispatching macro characters}
in the @i{readtable}.

@item @b{stream}  
Performing I/O operations on the @i{stream},
or @i{closing} the @i{stream}.

@item All other standardized types  
[This category includes, for example, @b{character},
                                      @b{condition},
                                      @b{function},
                                      @b{method-combination},
                                      @b{method},
                                      @b{number},
                                      @b{package},
                                      @b{pathname},
                                      @b{restart},
                                  and @b{symbol}.]

There are no @i{standardized} @i{destructive} operations
defined on @i{objects} of these @i{types}.

@end table

@node Transfer of Control during a Destructive Operation,  , Modification of Literal Objects, Destructive Operations
@subsection Transfer of Control during a Destructive Operation

Should a transfer of control out of a @i{destructive} operation occur
(@i{e.g.}, due to an error) the state of the @i{object} being modified is
@i{implementation-dependent}.

@menu
* Examples of Transfer of Control during a Destructive Operation::  
@end menu

@node Examples of Transfer of Control during a Destructive Operation,  , Transfer of Control during a Destructive Operation, Transfer of Control during a Destructive Operation
@subsubsection Examples of Transfer of Control during a Destructive Operation

The following examples illustrate some of the many ways in which the
@i{implementation-dependent} nature of the modification can manifest
itself.

@example
 (let ((a (list 2 1 4 3 7 6 'five)))
   (ignore-errors (sort a #'<))
   a)
@result{}  (1 2 3 4 6 7 FIVE)
@i{OR}@result{} (2 1 4 3 7 6 FIVE)
@i{OR}@result{} (2)

 (prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))
   (sort a #'(lambda (x y) (if (zerop (random 5)) (return-from foo a) (> x y)))))
@result{}  (1 2 3 4 5 6 7 8 9 10)
@i{OR}@result{} (3 4 5 6 2 7 8 9 10 1)
@i{OR}@result{} (1 2 4 3)
@end example

@c end of including concept-destruction

@node Evaluation and Compilation Dictionary,  , Destructive Operations, Evaluation and Compilation
@section Evaluation and Compilation Dictionary

@c including dict-eval-compile

@menu
* lambda (Symbol)::		
* lambda::			
* compile::			
* eval::			
* eval-when::			
* load-time-value::		
* quote::			
* compiler-macro-function::	
* define-compiler-macro::	
* defmacro::			
* macro-function::		
* macroexpand::			
* define-symbol-macro::		
* symbol-macrolet::		
* *macroexpand-hook*::		
* proclaim::			
* declaim::			
* declare::			
* ignore::			
* dynamic-extent::		
* type::			
* inline::			
* ftype::			
* declaration::			
* optimize::			
* special::			
* locally::			
* the::				
* special-operator-p::		
* constantp::			
@end menu

@node lambda (Symbol), lambda, Evaluation and Compilation Dictionary, Evaluation and Compilation Dictionary
@subsection lambda                                                             [Symbol]

@subsubheading  Syntax::

@code{lambda}  @i{lambda-list [[@{@i{declaration}@}* | @i{documentation}]] @{@i{form}@}*} 
@subsubheading  Arguments:: 

@i{lambda-list}---an @i{ordinary lambda list}.

@i{declaration}---a @b{declare} @i{expression}; not evaluated.

@i{documentation}---a @i{string}; not evaluated.

@i{form}---a @i{form}.

@subsubheading  Description::

A @i{lambda expression} is a @i{list} that can be used in place of a
@i{function name} in certain contexts to denote a @i{function} by 
directly describing its behavior rather than indirectly by referring to the 
name of an @i{established} @i{function}.

@i{Documentation} is attached to the denoted @i{function} (if any
is actually created) as a @i{documentation string}.

@subsubheading  See Also::

@b{function},
@ref{documentation}
,
@ref{Lambda Expressions},
@ref{Lambda Forms},
@ref{Syntactic Interaction of Documentation Strings and Declarations}

@subsubheading  Notes::

The @i{lambda form}

@example
 ((lambda @i{lambda-list} . @i{body}) . @i{arguments})
@end example

is semantically equivalent to the @i{function form}

@example
 (funcall #'(lambda @i{lambda-list} . @i{body}) . @i{arguments})
@end example

@node lambda, compile, lambda (Symbol), Evaluation and Compilation Dictionary
@subsection lambda                                                              [Macro]

@code{lambda}  @i{lambda-list [[@{@i{declaration}@}* | @i{documentation}]] @{@i{form}@}*} @result{}  @i{@i{function}}

@subsubheading  Arguments and Values:: 

@i{lambda-list}---an @i{ordinary lambda list}.

@i{declaration}---a @b{declare} @i{expression}; not evaluated.

@i{documentation}---a @i{string}; not evaluated.

@i{form}---a @i{form}.

@i{function}---a @i{function}.

@subsubheading  Description::

Provides a shorthand notation for a @b{function} @i{special form}
involving a @i{lambda expression} such that:

@example
    (lambda @i{lambda-list} [[@{@i{declaration}@}* | @i{documentation}]] @{@i{form}@}*)
 @equiv{} (function (lambda @i{lambda-list} [[@{@i{declaration}@}* | @i{documentation}]] @{@i{form}@}*))
 @equiv{} #'(lambda @i{lambda-list} [[@{@i{declaration}@}* | @i{documentation}]] @{@i{form}@}*)
@end example

@subsubheading  Examples::

@example
 (funcall (lambda (x) (+ x 3)) 4) @result{}  7
@end example

@subsubheading  See Also::

@b{lambda} (symbol)

@subsubheading  Notes::

This macro could be implemented by:

@example
(defmacro lambda (&whole form &rest bvl-decls-and-body)
  (declare (ignore bvl-decls-and-body))
  `#',form)
@end example

@node compile, eval, lambda, Evaluation and Compilation Dictionary
@subsection compile                                                          [Function]

@code{compile}  @i{name @r{&optional} definition} @result{}  @i{function, warnings-p, failure-p}

@subsubheading  Arguments and Values::

@i{name}---a @i{function name}, or @b{nil}.

@i{definition}---a @i{lambda expression} or a @i{function}.
  The default is the function definition of @i{name} if it names a @i{function},
	   or the @i{macro function} of @i{name} if it names a @i{macro}.
  The consequences are undefined if no @i{definition} is supplied
  when the @i{name} is @b{nil}.

@i{function}---the @i{function-name},

	        or a @i{compiled function}.

@i{warnings-p}---a @i{generalized boolean}.

@i{failure-p}---a @i{generalized boolean}.

@subsubheading  Description::

Compiles an @i{interpreted function}.

@b{compile} produces a @i{compiled function} from @i{definition}.
If the @i{definition} is a @i{lambda expression},
it is coerced to a @i{function}.  

If the @i{definition} is already a @i{compiled function},
@b{compile} either produces that function itself (@i{i.e.}, is an identity operation)
or an equivalent function.

[Editorial Note by KMP: There are a number of ambiguities here that still need resolution.]
If the @i{name} is @b{nil},
the resulting @i{compiled function} is returned directly as the @i{primary value}.
If a @i{non-nil} @i{name} is given, 
then the resulting @i{compiled function} replaces 
the existing @i{function} definition of @i{name}
and the @i{name} is returned as the @i{primary value};
if @i{name} is a @i{symbol} that names a @i{macro},
its @i{macro function} is updated
and the @i{name} is returned as the @i{primary value}.

@i{Literal objects} appearing in code processed by 
the @b{compile} function are neither copied nor @i{coalesced}.
The code resulting from the execution of @b{compile} 
references @i{objects} that are @b{eql} to the corresponding
@i{objects} in the source code.  

@b{compile} is permitted, but not required, to @i{establish}
a @i{handler} for @i{conditions} of @i{type} @b{error}.
For example, the @i{handler} might issue a warning and 
restart compilation from some @i{implementation-dependent} point 
in order to let the compilation proceed without manual intervention.

The @i{secondary value}, @i{warnings-p}, is @i{false}
if no @i{conditions} of @i{type} @b{error} or @b{warning}
were detected by the compiler, and @i{true} otherwise.

The @i{tertiary value}, @i{failure-p}, is @i{false}
if no @i{conditions} of @i{type} @b{error} or @b{warning}
(other than @b{style-warning})
were detected by the compiler, and @i{true} otherwise.

@subsubheading  Examples::

@example
 (defun foo () "bar") @result{}  FOO
 (compiled-function-p #'foo) @result{}  @i{implementation-dependent}
 (compile 'foo) @result{}  FOO 
 (compiled-function-p #'foo) @result{}  @i{true}
 (setf (symbol-function 'foo)
       (compile nil '(lambda () "replaced"))) @result{}  #<Compiled-Function>
 (foo) @result{}  "replaced"
@end example

@subsubheading  Affected By::

@b{*error-output*},

@b{*macroexpand-hook*}.

The presence of macro definitions and proclamations.

@subsubheading  Exceptional Situations::

The consequences are undefined if the @i{lexical environment} surrounding the
@i{function} to be compiled contains any @i{bindings} other than those for
@i{macros}, @i{symbol macros}, or @i{declarations}.

For information about errors detected during the compilation process, 
see @ref{Exceptional Situations in the Compiler}.

@subsubheading  See Also::

@ref{compile-file}

@node eval, eval-when, compile, Evaluation and Compilation Dictionary
@subsection eval                                                             [Function]

@code{eval}  @i{form} @result{}  @i{@{@i{result}@}*}

@subsubheading  Arguments and Values::

@i{form}---a @i{form}.

@i{results}---the @i{values} @i{yielded} by the @i{evaluation} of @i{form}.

@subsubheading  Description::                    

Evaluates @i{form} in the current @i{dynamic environment}
and the @i{null lexical environment}.

@b{eval} is a user interface to the evaluator.

The evaluator expands macro calls as if through the use of @b{macroexpand-1}.

Constants appearing in code
processed by @b{eval} are
not copied nor coalesced. The code resulting from the execution of 
@b{eval}
references @i{objects} 
that are @b{eql} to the corresponding @i{objects} in
the source code.  

@subsubheading  Examples::

@example
 (setq form '(1+ a) a 999) @result{}  999
 (eval form) @result{}  1000
 (eval 'form) @result{}  (1+ A)
 (let ((a '(this would break if eval used local value))) (eval form))
@result{}  1000
@end example

@subsubheading  See Also::

@b{macroexpand-1},
@ref{The Evaluation Model}

@subsubheading  Notes::

To obtain the current dynamic value of a @i{symbol}, 
use of @b{symbol-value} is equivalent (and usually preferable) 
to use of @b{eval}.

Note that an @b{eval} @i{form} involves two levels of @i{evaluation} 
for its @i{argument}.  First, @i{form} is @i{evaluated} by the
normal argument evaluation mechanism as would occur with any @i{call}.
The @i{object} that results from this normal @i{argument} @i{evaluation} 
becomes the @i{value} of the @i{form} @i{parameter}, and is then
@i{evaluated} as part of the @b{eval} @i{form}.
For example:

@example
 (eval (list 'cdr (car '((quote (a . b)) c)))) @result{}  b
@end example

The @i{argument} @i{form} @t{(list 'cdr (car '((quote (a . b)) c)))} is evaluated
in the usual way to produce the @i{argument} @t{(cdr (quote (a . b)))}; 
@b{eval} then evaluates its @i{argument}, @t{(cdr (quote (a . b)))}, to produce @t{b}.
Since a single @i{evaluation} already occurs for any @i{argument} @i{form}
in any @i{function form},
@b{eval} is sometimes said to perform ``an extra level of evaluation.''

@node eval-when, load-time-value, eval, Evaluation and Compilation Dictionary
@subsection eval-when                                                [Special Operator]

@code{eval-when}  @i{@r{(}@{@i{situation}@}*@r{)} @{@i{form}@}*} @result{}  @i{@{@i{result}@}*}

@subsubheading  Arguments and Values::

@i{situation}---One of the @i{symbols} 
		    @t{:compile-toplevel}
@c @IKindex{compile-toplevel}
,
		    @t{:load-toplevel}
@c @IKindex{load-toplevel}
,
		    @t{:execute}
@c @IKindex{execute}
,
		    @b{compile}
@IRindex compile
,
		    @b{load}
@IRindex load
, or
		    @b{eval}
@IRindex eval
.

The use of @b{eval}, @b{compile}, and @b{load} is deprecated.

@i{forms}---an @i{implicit progn}.

@i{results}---the @i{values} of the @i{forms} if they are executed,
		  or @b{nil} if they are not. 

@subsubheading  Description::

The body of an @b{eval-when} form is processed as an @i{implicit progn}, 
but only in the @i{situations} listed.  

The use of the @i{situations} @t{:compile-toplevel} (or @t{compile}) and
@t{:load-toplevel} (or @t{load}) controls whether and when @i{evaluation}
occurs when @b{eval-when} appears as a @i{top level form} in
code processed by @b{compile-file}.  See @ref{File Compilation}.

The use of the @i{situation} @t{:execute} (or @t{eval}) controls whether
evaluation occurs for other @b{eval-when} @i{forms}; that is, 
those that are not @i{top level forms}, or those in code processed by
@b{eval} or @b{compile}.  If the @t{:execute} situation is
specified in such a @i{form}, then the body @i{forms} are processed as 
an @i{implicit progn}; otherwise, the @b{eval-when} @i{form}
returns @b{nil}.

@b{eval-when} 
normally appears as a @i{top level form}, but it is meaningful
for it to appear as a @i{non-top-level form}.
However, the compile-time side
effects described in @ref{Compilation}
only take place when @b{eval-when} appears as a  
@i{top level form}.

@subsubheading  Examples::

One example of the use of @b{eval-when} is that for the 
compiler to be able to read a file properly when it uses user-defined
@i{reader macros}, it is necessary to write

@example
 (eval-when (:compile-toplevel :load-toplevel :execute)
   (set-macro-character #\$ #'(lambda (stream char)
                                (declare (ignore char))
                                (list 'dollar (read stream))))) @result{}  T
@end example

This causes the call to @b{set-macro-character} to be executed
in the compiler's execution environment, thereby modifying its
reader syntax table.

@example
;;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE
;;;     keyword is considered. At compile time, this has no effect.
;;;     At load time (if the LET is at toplevel), or at execution time
;;;     (if the LET is embedded in some other form which does not execute
;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which
;;;     returns 1.
 (let ((x 1))
   (eval-when (:execute :load-toplevel :compile-toplevel)
     (setf (symbol-function 'foo1) #'(lambda () x))))

;;;     If this expression occurs at the toplevel of a file to be compiled,
;;;     it has BOTH a compile time AND a load-time effect of setting
;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.
 (eval-when (:execute :load-toplevel :compile-toplevel)
   (let ((x 2))
     (eval-when (:execute :load-toplevel :compile-toplevel)
       (setf (symbol-function 'foo2) #'(lambda () x)))))

;;;     If this expression occurs at the toplevel of a file to be compiled,
;;;     it has BOTH a compile time AND a load-time effect of setting the
;;;     function cell of FOO3 to a function which returns 3.
 (eval-when (:execute :load-toplevel :compile-toplevel)
   (setf (symbol-function 'foo3) #'(lambda () 3)))

;;; #4: This always does nothing. It simply returns NIL.
 (eval-when (:compile-toplevel)
   (eval-when (:compile-toplevel) 
     (print 'foo4)))

;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is
;;;     printed at compile time. If this form occurs in a non-top-level
;;;     position, nothing is printed at compile time. Regardless of context,
;;;     nothing is ever printed at load time or execution time.
 (eval-when (:compile-toplevel) 
   (eval-when (:execute)
     (print 'foo5)))

;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is
;;;     printed at compile time.  If this form occurs in a non-top-level
;;;     position, nothing is printed at compile time. Regardless of context,
;;;     nothing is ever printed at load time or execution time.
 (eval-when (:execute :load-toplevel)
   (eval-when (:compile-toplevel)
     (print 'foo6)))
@end example

@subsubheading  See Also::

@ref{compile-file}
, @ref{Compilation}

@subsubheading  Notes::

The following effects are logical consequences of the definition of 
@b{eval-when}:

@table @asis

@item @t{*}  
Execution of a single @b{eval-when}
expression executes the body code at most once.

@item @t{*}  
@i{Macros} intended for use in @i{top level forms} 
should be written so that side-effects are done by the @i{forms}
in the macro expansion.  The macro-expander itself should not do 
the side-effects.

For example:

       Wrong:  

@example
 (defmacro foo ()
   (really-foo)
   `(really-foo))
@end example

      Right:  

@example
 (defmacro foo ()
   `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))
@end example

Adherence to this convention means that such @i{macros} behave
intuitively when appearing as @i{non-top-level forms}.

@item @t{*}  
Placing a variable binding around an @b{eval-when} reliably 
captures the binding because the compile-time-too mode cannot occur 
 (@i{i.e.}, introducing a variable binding means that the @b{eval-when}
      is not a @i{top level form}).
For example,

@example
 (let ((x 3))
   (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))
@end example

prints @t{3} 
at execution (@i{i.e.}, load) time, and does not print anything at
compile time.  This is important so that expansions of 
@b{defun} and 
@b{defmacro} 
can be done in terms of @b{eval-when} and can correctly capture
the @i{lexical environment}.

@example
 (defun bar (x) (defun foo () (+ x 3)))
@end example

might expand into

@example
 (defun bar (x) 
   (progn (eval-when (:compile-toplevel) 
            (compiler::notice-function-definition 'foo '(x)))
          (eval-when (:execute :load-toplevel)
            (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))
@end example

which would be treated by the above rules the same as

@example
 (defun bar (x) 
   (setf (symbol-function 'foo) #'(lambda () (+ x 3))))
@end example

when the definition of @t{bar} is not a @i{top level form}.
@end table

@node load-time-value, quote, eval-when, Evaluation and Compilation Dictionary
@subsection load-time-value                                          [Special Operator]

@code{load-time-value}  @i{form @r{&optional} read-only-p} @result{}  @i{object}

@subsubheading  Arguments and Values::         

@i{form}---a @i{form}; evaluated as described below.

@i{read-only-p}---a @i{boolean}; not evaluated.

@i{object}---the @i{primary value} resulting from evaluating @i{form}.

@subsubheading  Description::

@b{load-time-value} provides a mechanism for delaying evaluation of @i{form}
until the expression is in the run-time environment; see @ref{Compilation}.

@i{Read-only-p} designates whether the result can be considered a
@i{constant object}.
If @b{t},
   the result is a read-only quantity that can, 
   if appropriate to the @i{implementation}, 
   be copied into read-only space and/or @i{coalesced} with @i{similar}
   @i{constant objects} from other @i{programs}.
If @b{nil} (the default),
   the result must be neither copied nor coalesced;
   it must be considered to be potentially modifiable data.

If a @b{load-time-value} expression is processed by @b{compile-file},
the compiler performs its normal semantic processing (such as macro expansion 
and translation into machine code) on @i{form}, but arranges for the
execution of @i{form} to occur at load time in a @i{null lexical environment}, 
with the result of this @i{evaluation} then being treated as 
a @i{literal object}
at run time.  It is guaranteed that the evaluation of @i{form} 
will take place only once when the @i{file} is @i{loaded}, but 
the order of evaluation with respect to the evaluation of
@i{top level forms} in the file is @i{implementation-dependent}.

@ITindex order of evaluation

@ITindex evaluation order

If a @b{load-time-value} expression appears within a function compiled
with @b{compile}, the @i{form} is evaluated at compile time in a
@i{null lexical environment}.  The result of this compile-time evaluation 
is treated as
a @i{literal object}
in the compiled code.  

If a @b{load-time-value} expression is processed by @b{eval},
@i{form} is evaluated in a @i{null lexical environment}, 
and one value is returned.  Implementations that implicitly compile
(or partially compile) expressions processed by @b{eval} 
might evaluate @i{form} only once, at the time this compilation is performed.  

If the @i{same} @i{list} @t{(load-time-value @i{form})} is
evaluated or compiled more than once, it is @i{implementation-dependent}
whether @i{form} is evaluated only once or is evaluated more than once.
This can happen both when an expression being evaluated or compiled shares
substructure, and when the @i{same} @i{form} is processed by @b{eval} or 
@b{compile} multiple times.                               
Since a @b{load-time-value} expression can be
  referenced in more than one place and can be evaluated multiple times
  by @b{eval}, it is 
@i{implementation-dependent} whether each execution returns
  a fresh @i{object} 
or returns the same @i{object} as some other execution.
  Users must use caution when destructively modifying the resulting
  @i{object}.

If two lists @t{(load-time-value @i{form})} 
that are the @i{same} under @b{equal} but are not @i{identical}
are evaluated or compiled,
their values always come from distinct evaluations of @i{form}.
Their @i{values} may not be coalesced
unless @i{read-only-p} is @b{t}.

@subsubheading  Examples::

@example
;;; The function INCR1 always returns the same value, even in different images.
;;; The function INCR2 always returns the same value in a given image, 
;;; but the value it returns might vary from image to image.
(defun incr1 (x) (+ x #.(random 17)))
(defun incr2 (x) (+ x (load-time-value (random 17))))

;;; The function FOO1-REF references the nth element of the first of 
;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for
;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the
;;; updated values.
(defvar *foo-arrays* (list (make-array 7) (make-array 8)))
(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))
(defun set-foo1-ref (n val) 
  (setf (aref (load-time-value (first *my-arrays*) nil) n) val))

;;; The function BAR1-REF references the nth element of the first of 
;;; the *BAR-ARRAYS* that is available at load time.  The programmer has
;;; promised that the array will be treated as read-only, so the system 
;;; can copy or coalesce the array.
(defvar *bar-arrays* (list (make-array 7) (make-array 8)))
(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))

;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified, because the object was already read-only
;;; when it was written as a literal vector rather than created by a constructor.
;;; User programs must treat the vector v as read-only.
(defun baz-ref (n)
  (let ((v (load-time-value #(A B C) nil)))
    (values (svref v n) v)))

;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified in the outer situation because T was specified
;;; in the inner situation.  User programs must treat the vector v as read-only.
(defun baz-ref (n)
  (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))
    (values (svref v n) v)))
@end example

@subsubheading  See Also::

@ref{compile-file}
,
@ref{compile}
,
@ref{eval}
,
@ref{Minimal Compilation},
@ref{Compilation}

@subsubheading  Notes::

@b{load-time-value} must appear outside of quoted structure in a
``for @i{evaluation}'' position.  In situations which would appear to call
for use of @b{load-time-value} within a quoted structure, 
the @i{backquote} @i{reader macro} is probably called for;
see @ref{Backquote}.

Specifying @b{nil} for @i{read-only-p} is not a way to force an object
to become modifiable if it has already been made read-only.  It is only a way
to say that, for an object that is modifiable, this operation is not intended
to make that object read-only.

@node quote, compiler-macro-function, load-time-value, Evaluation and Compilation Dictionary
@subsection quote                                                    [Special Operator]

@code{quote}  @i{object} @result{}  @i{object}

@subsubheading  Arguments and Values:: 

@i{object}---an @i{object}; not evaluated.

@subsubheading  Description::

The @b{quote} @i{special operator} just returns @i{object}.

The consequences are undefined if @i{literal objects} (including
@i{quoted objects}) are destructively modified.

@subsubheading  Examples::

@example
 (setq a 1) @result{}  1
 (quote (setq a 3)) @result{}  (SETQ A 3)
 a @result{}  1
 'a @result{}  A
 ''a @result{}  (QUOTE A) 
 '''a @result{}  (QUOTE (QUOTE A))
 (setq a 43) @result{}  43
 (list a (cons a 3)) @result{}  (43 (43 . 3))
 (list (quote a) (quote (cons a 3))) @result{}  (A (CONS A 3)) 
 1 @result{}  1
 '1 @result{}  1
 "foo" @result{}  "foo"
 '"foo" @result{}  "foo"
 (car '(a b)) @result{}  A
 '(car '(a b)) @result{}  (CAR (QUOTE (A B)))
 #(car '(a b)) @result{}  #(CAR (QUOTE (A B)))
 '#(car '(a b)) @result{}  #(CAR (QUOTE (A B)))
@end example

@subsubheading  See Also::

@ref{Evaluation},
@ref{Single-Quote},

@ref{Compiler Terminology}

@subsubheading  Notes::

The textual notation @t{'@i{object}} is equivalent to @t{(quote @i{object})};
see @ref{Compiler Terminology}.

Some @i{objects}, called @i{self-evaluating objects}, 
do not require quotation by @b{quote}.  
However, @i{symbols} and @i{lists} are used to represent parts of programs,
and so would not be useable as constant data in a program without @b{quote}.
Since @b{quote} suppresses the @i{evaluation} of these @i{objects},
they become data rather than program.

@node compiler-macro-function, define-compiler-macro, quote, Evaluation and Compilation Dictionary
@subsection compiler-macro-function                                          [Accessor]

@code{compiler-macro-function}  @i{name @r{&optional} environment} @result{}  @i{function}

(setf (@code{         compiler-macro-function} @i{name @r{&optional} environment}) new-function)@*

@subsubheading  Arguments and Values::

@i{name}---a @i{function name}.

@i{environment}---an @i{environment} @i{object}.

@i{function}, @i{new-function}---a @i{compiler macro function}, or @b{nil}.

@subsubheading  Description::

@i{Accesses} the @i{compiler macro function} named @i{name}, if any,
in the @i{environment}.

A value of @b{nil} denotes the absence of a @i{compiler macro function} named @i{name}.

@subsubheading  Exceptional Situations::

The consequences are undefined if @i{environment} is @i{non-nil}
in a use of @b{setf} of @b{compiler-macro-function}.

@subsubheading  See Also::

@ref{define-compiler-macro}
, @ref{Compiler Macros}

@node define-compiler-macro, defmacro, compiler-macro-function, Evaluation and Compilation Dictionary
@subsection define-compiler-macro                                               [Macro]

@code{define-compiler-macro}  @i{name lambda-list [[@{@i{declaration}@}* | @i{documentation}]] @{@i{form}@}*}@*
   @result{}  @i{name}

@subsubheading  Arguments and Values::

@i{name}---a @i{function name}.

@i{lambda-list}---a @i{macro lambda list}.

@i{declaration}---a @b{declare} @i{expression}; not evaluated.

@i{documentation}---a @i{string}; not evaluated.

@i{form}---a @i{form}.

@subsubheading  Description::

[Editorial Note by KMP: This definition probably needs to be fully expanded to not
	 	 refer through the definition of defmacro, but should suffice for now.]

This is the normal mechanism for defining a @i{compiler macro function}.
Its manner of definition is the same as for @b{defmacro}; the only
differences are:

@table @asis

@item @t{*}  
The @i{name} can be a @i{function name} naming
 any @i{function} or @i{macro}.

@item @t{*}  
The expander function is installed as a @i{compiler macro function}
 for the @i{name}, rather than as a @i{macro function}.

@item @t{*}  
The @b{&whole} argument is bound to the form argument that 
 is passed to the @i{compiler macro function}.  The remaining lambda-list 
 parameters are specified as if this form contained the function name in the
 @i{car} and the actual arguments in the @i{cdr}, but if the @i{car} 
 of the actual form is the symbol @b{funcall}, then the destructuring of 
 the arguments is actually performed using its @i{cddr} instead.

@item @t{*}  

 @i{Documentation} is attached as a @i{documentation string} 
    to @i{name} (as kind @b{compiler-macro})
and to the @i{compiler macro function}.

@item @t{*}  
Unlike an ordinary @i{macro}, a @i{compiler macro}
 can decline to provide an expansion merely by returning a form that is
 the @i{same} as the original (which can be obtained by using
 @b{&whole}).
@end table

@subsubheading  Examples::

@example
 (defun square (x) (expt x 2)) @result{}  SQUARE
 (define-compiler-macro square (&whole form arg)
   (if (atom arg)
       `(expt ,arg 2)
       (case (car arg)
         (square (if (= (length arg) 2)
                     `(expt ,(nth 1 arg) 4)
                     form))
         (expt   (if (= (length arg) 3)
                     (if (numberp (nth 2 arg))
                         `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))
                         `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))
                     form))
         (otherwise `(expt ,arg 2))))) @result{}  SQUARE
 (square (square 3)) @result{}  81
 (macroexpand '(square x)) @result{}  (SQUARE X), @i{false}
 (funcall (compiler-macro-function 'square) '(square x) nil)
@result{}  (EXPT X 2)
 (funcall (compiler-macro-function 'square) '(square (square x)) nil)
@result{}  (EXPT X 4)
 (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)
@result{}  (EXPT X 2)

 (defun distance-positional (x1 y1 x2 y2)
   (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))
@result{}  DISTANCE-POSITIONAL
 (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))
   (distance-positional x1 y1 x2 y2))
@result{}  DISTANCE
 (define-compiler-macro distance (&whole form
                                  &rest key-value-pairs
                                  &key (x1 0  x1-p)
                                       (y1 0  y1-p)
                                       (x2 x1 x2-p)
                                       (y2 y1 y2-p)
                                  &allow-other-keys
                                  &environment env)
   (flet ((key (n) (nth (* n 2) key-value-pairs))
          (arg (n) (nth (1+ (* n 2)) key-value-pairs))
          (simplep (x)
            (let ((expanded-x (macroexpand x env)))
              (or (constantp expanded-x env)
                  (symbolp expanded-x)))))
     (let ((n (/ (length key-value-pairs) 2)))
       (multiple-value-bind (x1s y1s x2s y2s others)
           (loop for (key) on key-value-pairs by #'cddr
                 count (eq key ':x1) into x1s
                 count (eq key ':y1) into y1s
                 count (eq key ':x2) into x2s
                 count (eq key ':y1) into y2s
                 count (not (member key '(:x1 :x2 :y1 :y2)))
                   into others
                 finally (return (values x1s y1s x2s y2s others)))
         (cond ((and (= n 4)
                     (eq (key 0) :x1)
                     (eq (key 1) :y1)
                     (eq (key 2) :x2)
                     (eq (key 3) :y2))
                `(distance-positional ,x1 ,y1 ,x2 ,y2))
               ((and (if x1-p (and (= x1s 1) (simplep x1)) t)
                     (if y1-p (and (= y1s 1) (simplep y1)) t)
                     (if x2-p (and (= x2s 1) (simplep x2)) t)
                     (if y2-p (and (= y2s 1) (simplep y2)) t)
                     (zerop others))
                `(distance-positional ,x1 ,y1 ,x2 ,y2))
               ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)
                     (zerop others))
                (let ((temps (loop repeat n collect (gensym))))
                  `(let ,(loop for i below n
                               collect (list (nth i temps) (arg i)))
                     (distance
                       ,@@(loop for i below n
                               append (list (key i) (nth i temps)))))))
               (t form))))))
@result{}  DISTANCE
 (dolist (form
           '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))
             (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))
             (distance :x1 (setq x 7) :y1 (incf x))
             (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))
             (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)
             (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)
             (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))
   (print (funcall (compiler-macro-function 'distance) form nil)))
@t{ |> } (LET ((#:G6558 (SETQ X 7))
@t{ |> }       (#:G6559 (DECF X))
@t{ |> }       (#:G6560 (DECF X))
@t{ |> }       (#:G6561 (DECF X)))
@t{ |> }   (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561)) 
@t{ |> } (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X)) 
@t{ |> } (LET ((#:G6567 (SETQ X 7))
@t{ |> }       (#:G6568 (INCF X)))
@t{ |> }   (DISTANCE :X1 #:G6567 :Y1 #:G6568)) 
@t{ |> } (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X)) 
@t{ |> } (DISTANCE-POSITIONAL A1 B1 A2 B2) 
@t{ |> } (DISTANCE-POSITIONAL A1 B1 A2 B2) 
@t{ |> } (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2) 
@result{}  NIL
@end example

@subsubheading  See Also::

@ref{compiler-macro-function}
,
@ref{defmacro}
,
@ref{documentation}
,
@ref{Syntactic Interaction of Documentation Strings and Declarations}

@subsubheading  Notes::

The consequences of writing a @i{compiler macro} definition for a function
in the @t{COMMON-LISP} @i{package} are undefined; it is quite possible that in some
@i{implementations} such an attempt would override an equivalent or equally
important definition.  In general, it is recommended that a programmer only
write @i{compiler macro} definitions for @i{functions} he or she personally 
maintains--writing a @i{compiler macro} definition for a function maintained
elsewhere is normally considered a violation of traditional rules of modularity
and data abstraction.

@node defmacro, macro-function, define-compiler-macro, Evaluation and Compilation Dictionary
@subsection defmacro                                                            [Macro]

@code{defmacro}  @i{name lambda-list [[@{@i{declaration}@}* | @i{documentation}]] @{@i{form}@}*}@*
   @result{}  @i{name}

@subsubheading  Arguments and Values::

@i{name}---a @i{symbol}. 

@i{lambda-list}---a @i{macro lambda list}.

@i{declaration}---a @b{declare} @i{expression}; not evaluated.

@i{documentation}---a @i{string}; not evaluated.

@i{form}---a @i{form}.

@subsubheading  Description::

Defines @i{name} as a @i{macro} 
by associating a @i{macro function} with that @i{name}
in the global environment.

The @i{macro function} is defined in the same @i{lexical environment}
in which the @b{defmacro} @i{form} appears.

The parameter variables in @i{lambda-list} are bound to
destructured portions of the macro call.

The expansion function
accepts two arguments, a @i{form} and an 
@i{environment}.  The expansion function returns a @i{form}.  
The body of the expansion function is specified by @i{forms}.
@i{Forms} are executed in order.  The value of the
last @i{form} executed is returned as the expansion of the
@i{macro}.

The body @i{forms} of the expansion function (but not the @i{lambda-list})

are implicitly enclosed in a @i{block} whose name is @i{name}.

The @i{lambda-list} conforms to the requirements described in @ref{Macro Lambda Lists}.

@i{Documentation} is attached as a @i{documentation string} 
    to @i{name} (as kind @b{function})
and to the @i{macro function}.

@b{defmacro} can be used to redefine a @i{macro} or to replace
a @i{function} definition with a @i{macro} definition.

Recursive expansion of the @i{form} returned must terminate,
including the expansion of other @i{macros} which are @i{subforms}
of other @i{forms} returned.

The consequences are undefined if the result of fully macroexpanding
a @i{form}
contains any @i{circular} @i{list structure} except in @i{literal objects}.

If a @b{defmacro} @i{form} appears as a @i{top level form},
the @i{compiler} must store the @i{macro} definition at compile time,
so that occurrences of the macro later on in the file can be expanded correctly.
Users must ensure that the body of the @i{macro} can be evaluated at 
compile time if it is referenced within the @i{file} being @i{compiled}.

@subsubheading  Examples::

@example
 (defmacro mac1 (a b) "Mac1 multiplies and adds" 
            `(+ ,a (* ,b 3))) @result{}  MAC1 
 (mac1 4 5) @result{}  19 
 (documentation 'mac1 'function) @result{}  "Mac1 multiplies and adds" 
 (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) @result{}  MAC2 
 (mac2 6) @result{}  (6 T 3 NIL NIL) 
 (mac2 6 3 8) @result{}  (6 T 3 T (8)) 
 (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))
    `'(,r ,a ,b ,c ,d ,x)) @result{}  MAC3 
 (mac3 1 6 :d 8 :c 9 :d 10) @result{}  ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10)) 
@end example

The stipulation that
an embedded @i{destructuring lambda list} is permitted only
where @i{ordinary lambda list} syntax would permit a parameter name
but not a @i{list} is made to prevent ambiguity.  For example,
the following is not valid:

@example
 (defmacro loser (x &optional (a b &rest c) &rest z)
   ...)
@end example

because @i{ordinary lambda list} syntax does permit a 
@i{list} following @t{&optional};
the list @t{(a b &rest c)} would be interpreted as describing an
optional parameter named @t{a} whose default value is that of the
form @t{b}, with a supplied-p parameter named @b{&rest} (not valid),
and an extraneous symbol @t{c} in the list (also not valid).  An almost
correct way to express this is

@example
 (defmacro loser (x &optional ((a b &rest c)) &rest z)
   ...)
@end example

The extra set of parentheses removes the ambiguity.  However, the
definition is now incorrect because a macro call such as @t{(loser (car pool))}
would not provide any argument form for the lambda list @t{(a b &rest c)},
and so the default value against which to match the @i{lambda list} would be
@b{nil} because no explicit default value was specified.  
The consequences of this are  unspecified
since the empty list, @b{nil}, does not have @i{forms} to satisfy the
parameters @t{a} and @t{b}.  The fully correct definition would be either

@example
 (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)
   ...)
@end example

or

@example
 (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)
   ...)
@end example

These differ slightly: the first requires that if the macro call
specifies @t{a} explicitly then it must also specify @t{b} explicitly,
whereas the second does not have this requirement.  For example,

@example
 (loser (car pool) ((+ x 1)))
@end example

would be a valid call for the second definition but not for the first.

@example
 (defmacro dm1a (&whole x) `',x)
 (macroexpand '(dm1a))  @result{}  (QUOTE (DM1A))
 (macroexpand '(dm1a a)) is an error.

 (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))
 (macroexpand '(dm1b))  is an error.
 (macroexpand '(dm1b q))  @result{}  (QUOTE ((DM1B Q) Q NIL))
 (macroexpand '(dm1b q r)) @result{}  (QUOTE ((DM1B Q R) Q R))
 (macroexpand '(dm1b q r s)) is an error.
@end example

@example
 (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))
 (macroexpand '(dm2a x y)) @result{}  (QUOTE (FORM (DM2A X Y) A X B Y))
 (dm2a x y) @result{}  (FORM (DM2A X Y) A X B Y)

 (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5)) 
                 &body f &environment env)
   ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))
 ;Note that because backquote is involved, implementations may differ
 ;slightly in the nature (though not the functionality) of the expansion.
 (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))
 @result{}  (LIST* '(DM2B X1 (((INCF X2) X3 X4))
                   X5 X6)
            X1
            '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),
     T
 (let ((x1 5))
   (macrolet ((segundo (x) `(cadr ,x)))
     (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))
 @result{}  ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)
      5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))
@end example

@subsubheading  See Also::

@ref{define-compiler-macro}
,

@ref{destructuring-bind}
, 
@ref{documentation}
,
@ref{macroexpand}
,
@b{*macroexpand-hook*},
@b{macrolet}, 
@ref{macro-function}
, 
@ref{Evaluation},
@ref{Compilation},
@ref{Syntactic Interaction of Documentation Strings and Declarations}

@node macro-function, macroexpand, defmacro, Evaluation and Compilation Dictionary
@subsection macro-function                                                   [Accessor]

@code{macro-function}  @i{symbol @r{&optional} environment} @result{}  @i{function}

(setf (@code{         macro-function} @i{symbol @r{&optional} environment}) new-function)@*

@subsubheading  Arguments and Values::

@i{symbol}---a @i{symbol}.

@i{environment}---an @i{environment} @i{object}.

@i{function}---a @i{macro function} or @b{nil}.

@i{new-function}---a @i{macro function}.

@subsubheading  Description::

Determines whether @i{symbol} has a function definition 
as a macro in the specified @i{environment}.

If so, the macro expansion function, a function of two arguments,
is returned.  If @i{symbol} has no function definition
in the lexical environment @i{environment}, or its definition
is not a @i{macro}, @b{macro-function} returns @b{nil}.

It is possible for both @b{macro-function} and 

@b{special-operator-p}

to return @i{true} of @i{symbol}.  The @i{macro} definition must
be available for use by programs that understand only the standard 
@r{Common Lisp} @i{special forms}.

@subsubheading  Examples::
@example
 (defmacro macfun (x) '(macro-function 'macfun)) @result{}  MACFUN 
 (not (macro-function 'macfun)) @result{}  @i{false} 
@end example

@example
 (macrolet ((foo (&environment env)
               (if (macro-function 'bar env)
                  ''yes
                  ''no)))
    (list (foo)
          (macrolet ((bar () :beep))
             (foo))))

@result{}  (NO YES)
@end example

@subsubheading  Affected By::
@t{(setf macro-function)}, @b{defmacro}, and @b{macrolet}.

@subsubheading  Exceptional Situations::

The consequences are undefined if @i{environment} is @i{non-nil}
in a use of @b{setf} of @b{macro-function}.

@subsubheading  See Also::

@ref{defmacro}
, @ref{Evaluation}

@subsubheading  Notes::

@b{setf} can be used with @b{macro-function} to install
a @i{macro} as a symbol's global function definition:

@example
 (setf (macro-function symbol) fn)
@end example

The value installed must be a @i{function} that accepts two arguments,
the entire macro call and an @i{environment}, 
and computes the expansion for that call.
Performing this operation causes @i{symbol} to have only that
macro definition as its global function definition; any previous
definition, whether as a @i{macro} or as a 
@i{function}, is lost.

@node macroexpand, define-symbol-macro, macro-function, Evaluation and Compilation Dictionary
@subsection macroexpand, macroexpand-1                                       [Function]

@code{macroexpand}  @i{form @r{&optional} env} @result{}  @i{expansion, expanded-p}

@code{macroexpand-}  @i{1} @result{}  @i{form @r{&optional} env}
 @r{expansion, expanded-p}

@subsubheading  Arguments and Values::

@i{form}---a @i{form}.

@i{env}---an @i{environment} @i{object}.
  The default is @b{nil}.

@i{expansion}---a @i{form}.

@i{expanded-p}---a @i{generalized boolean}.

@subsubheading  Description::

@b{macroexpand} and @b{macroexpand-1} expand @i{macros}.

If @i{form} is a @i{macro form},
then @b{macroexpand-1} expands the @i{macro form} call once.

@b{macroexpand} 
repeatedly expands @i{form} until it is no longer a @i{macro form}.
In effect, @b{macroexpand} calls @b{macroexpand-1} repeatedly
until the @i{secondary value} it returns is @b{nil}.

If @i{form} is a @i{macro form},
then the @i{expansion} is a @i{macro expansion}
 and @i{expanded-p} is @i{true}.
Otherwise,
 the @i{expansion} is the given @i{form}
 and @i{expanded-p} is @i{false}.

Macro expansion is carried out as follows.  
Once @b{macroexpand-1} has
determined that the @i{form} is a @i{macro form},
it obtains an appropriate expansion @i{function} for the
@i{macro} or @i{symbol macro}.
The value of 
@b{*macroexpand-hook*} is 

coerced to a @i{function} and

then called as a @i{function} of three arguments:
      the expansion @i{function},
      the @i{form},
  and the @i{env}.
The @i{value} returned from this call is taken to be the expansion
of the @i{form}.

In addition to @i{macro} definitions in the global environment,
any local macro definitions established within @i{env} by @b{macrolet} 
or @b{symbol-macrolet} are considered.
If only @i{form} is supplied as an argument,
then the environment is effectively null, and only global macro definitions
as established by @b{defmacro} are considered.
@i{Macro} definitions are shadowed by local @i{function} definitions.

@subsubheading  Examples::

@example
 (defmacro alpha (x y) `(beta ,x ,y)) @result{}  ALPHA
 (defmacro beta (x y) `(gamma ,x ,y)) @result{}  BETA
 (defmacro delta (x y) `(gamma ,x ,y)) @result{}  EPSILON
 (defmacro expand (form &environment env)
   (multiple-value-bind (expansion expanded-p)
       (macroexpand form env)
     `(values ',expansion ',expanded-p))) @result{}  EXPAND
 (defmacro expand-1 (form &environment env)
   (multiple-value-bind (expansion expanded-p)
       (macroexpand-1 form env)
     `(values ',expansion ',expanded-p))) @result{}  EXPAND-1

;; Simple examples involving just the global environment
 (macroexpand-1 '(alpha a b)) @result{}  (BETA A B), @i{true}
 (expand-1 (alpha a b)) @result{}  (BETA A B), @i{true}
 (macroexpand '(alpha a b)) @result{}  (GAMMA A B), @i{true}
 (expand (alpha a b)) @result{}  (GAMMA A B), @i{true}
 (macroexpand-1 'not-a-macro) @result{}  NOT-A-MACRO, @i{false}
 (expand-1 not-a-macro) @result{}  NOT-A-MACRO, @i{false}
 (macroexpand '(not-a-macro a b)) @result{}  (NOT-A-MACRO A B), @i{false}
 (expand (not-a-macro a b)) @result{}  (NOT-A-MACRO A B), @i{false}

;; Examples involving lexical environments
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (macroexpand-1 '(alpha a b))) @result{}  (BETA A B), @i{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (expand-1 (alpha a b))) @result{}  (DELTA A B), @i{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (macroexpand '(alpha a b))) @result{}  (GAMMA A B), @i{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (expand (alpha a b))) @result{}  (GAMMA A B), @i{true}
 (macrolet ((beta (x y) `(epsilon ,x ,y)))
   (expand (alpha a b))) @result{}  (EPSILON A B), @i{true}
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (expand a))) @result{}  (FIRST X), @i{true}
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (macroexpand 'a))) @result{}  A, @i{false}
 (symbol-macrolet ((b (alpha x y)))
   (expand-1 b)) @result{}  (ALPHA X Y), @i{true}
 (symbol-macrolet ((b (alpha x y)))
   (expand b)) @result{}  (GAMMA X Y), @i{true}
 (symbol-macrolet ((b (alpha x y))
                   (a b))
   (expand-1 a)) @result{}  B, @i{true}
 (symbol-macrolet ((b (alpha x y))
                   (a b))
   (expand a)) @result{}  (GAMMA X Y), @i{true}

;; Examples of shadowing behavior
 (flet ((beta (x y) (+ x y)))
   (expand (alpha a b))) @result{}  (BETA A B), @i{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (flet ((alpha (x y) (+ x y)))
     (expand (alpha a b)))) @result{}  (ALPHA A B), @i{false}
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (let ((a x))
       (expand a)))) @result{}  A, @i{false}
@end example

@subsubheading  Affected By::

@b{defmacro},
@b{setf} of @b{macro-function},
@b{macrolet},
@b{symbol-macrolet}

@subsubheading  See Also::     

@b{*macroexpand-hook*},
@ref{defmacro}
,
@ref{setf}
 of 
@ref{macro-function}
,
@b{macrolet},
@ref{symbol-macrolet}
,
@ref{Evaluation}

@subsubheading  Notes::

Neither @b{macroexpand} nor @b{macroexpand-1} 
makes any explicit attempt to expand @i{macro forms} that are
either @i{subforms} of the @i{form} 
    or @i{subforms} of the @i{expansion}.
Such expansion might occur implicitly, however,
due to the semantics or implementation of the @i{macro function}.

@node define-symbol-macro, symbol-macrolet, macroexpand, Evaluation and Compilation Dictionary
@subsection define-symbol-macro                                                 [Macro]

@code{define-symbol-macro}  @i{symbol expansion}@*
   @result{}  @i{symbol}

@subsubheading  Arguments and Values::

@i{symbol}---a @i{symbol}.

@i{expansion}---a @i{form}.

@subsubheading  Description::

Provides a mechanism for globally affecting the @i{macro expansion}
of the indicated @i{symbol}.

Globally establishes an expansion function for the @i{symbol macro} 
named by @i{symbol}.
The only guaranteed property of an expansion @i{function} for a @i{symbol macro}
is that when it is applied to the @i{form} and the @i{environment} it returns
the correct expansion.  (In particular, it is @i{implementation-dependent} 
whether the expansion is conceptually stored in the expansion function,
the @i{environment}, or both.)

Each global reference to @i{symbol} (@i{i.e.}, not @i{shadowed}_2 by a 
@i{binding} for a @i{variable} or @i{symbol macro} named by
the same @i{symbol}) is expanded by the normal macro expansion process;
see @ref{Symbols as Forms}.
The expansion of a @i{symbol macro} is subject to further @i{macro expansion}
in the same @i{lexical environment} as the @i{symbol macro} reference,
exactly analogous to normal @i{macros}.

The consequences are unspecified if a @b{special} declaration is made for
@i{symbol} while in the scope of this definition (@i{i.e.}, when it is not 
@i{shadowed}_2 by a @i{binding} for a @i{variable}
or @i{symbol macro} named by the same @i{symbol}).

Any use of @b{setq} to set the value of 
the @i{symbol}
 while in the scope of this definition
 is treated as if it were a @b{setf}.
@b{psetq} of @i{symbol}
 is treated as if it were a @b{psetf}, and
@b{multiple-value-setq} 
 is treated as if it were a @b{setf} of @b{values}.

A @i{binding} for a @i{symbol macro} can be @i{shadowed}_2
by @b{let} or @b{symbol-macrolet}.

@subsubheading  Examples::

@example
(defvar *things* (list 'alpha 'beta 'gamma)) @result{}  *THINGS*

(define-symbol-macro thing1 (first *things*)) @result{}  THING1
(define-symbol-macro thing2 (second *things*)) @result{}  THING2
(define-symbol-macro thing3 (third *things*)) @result{}  THING3

thing1 @result{}  ALPHA
(setq thing1 'ONE) @result{}  ONE
*things* @result{}  (ONE BETA GAMMA)
(multiple-value-setq (thing2 thing3) (values 'two 'three)) @result{}  TWO
thing3 @result{}  THREE
*things* @result{}  (ONE TWO THREE)

(list thing2 (let ((thing2 2)) thing2)) @result{}  (TWO 2)
@end example

@subsubheading  Exceptional Situations::

If @i{symbol} is already defined as a @i{global variable},
an error of @i{type} @b{program-error} is signaled.

@subsubheading  See Also::

@ref{symbol-macrolet}
,
@ref{macroexpand}

@node symbol-macrolet, *macroexpand-hook*, define-symbol-macro, Evaluation and Compilation Dictionary
@subsection symbol-macrolet                                          [Special Operator]

@code{symbol-macrolet}  @i{@r{(}@{@r{(}symbol expansion @r{)}@}*@r{)}
			   @{@i{declaration}@}* 
			   @{@i{form}@}*}@*
   @result{}  @i{@{@i{result}@}*}

@subsubheading  Arguments and Values::

@i{symbol}---a @i{symbol}.

@i{expansion}---a @i{form}.

@i{declaration}---a @b{declare} @i{expression}; not evaluated.

@i{forms}---an @i{implicit progn}.

@i{results}---the @i{values} returned by the @i{forms}.

@subsubheading  Description::

@b{symbol-macrolet} provides a mechanism for 
affecting the @i{macro expansion} environment for @i{symbols}.

@b{symbol-macrolet} lexically establishes expansion functions
for each of the @i{symbol macros} named by @i{symbols}.

The only guaranteed property of an expansion @i{function} for a @i{symbol macro}
is that when it is applied to the @i{form} and the @i{environment} it returns
the correct expansion.  (In particular, it is @i{implementation-dependent} 
whether the expansion is conceptually stored in the expansion function,
the @i{environment}, or both.)

Each reference to @i{symbol} as a variable within the lexical @i{scope}
of @b{symbol-macrolet} is expanded by the normal macro expansion process;
see @ref{Symbols as Forms}.
The expansion of a symbol macro is subject to further macro expansion
in the same lexical environment as the symbol macro invocation, exactly 
analogous to normal @i{macros}.

Exactly the same @i{declarations} are allowed as for @b{let}
with one exception: @b{symbol-macrolet} signals an error
if a @b{special} declaration names one of the @i{symbols} 
being defined by @b{symbol-macrolet}.  

When the @i{forms} of the @b{symbol-macrolet} form are expanded, 
any use of @b{setq} to set the value of one of the specified variables 
 is treated as if it were a @b{setf}.
@b{psetq} of a @i{symbol} defined as a symbol macro 
 is treated as if it were a @b{psetf}, and
@b{multiple-value-setq} 
 is treated as if it were a @b{setf} of @b{values}.

The use of @b{symbol-macrolet} can be shadowed by @b{let}.
In other words, @b{symbol-macrolet} only substitutes for occurrences
of @i{symbol} that would be in the @i{scope} of a lexical binding of
@i{symbol} surrounding the @i{forms}.

@subsubheading  Examples::

@example
;;; The following is equivalent to
;;;   (list 'foo (let ((x 'bar)) x)),
;;; not
;;;   (list 'foo (let (('foo 'bar)) 'foo))
 (symbol-macrolet ((x 'foo))
   (list x (let ((x 'bar)) x))) 
@result{}  (foo bar)
@i{NOT}@result{} (foo foo) 

 (symbol-macrolet ((x '(foo x)))
   (list x))
@result{}  ((FOO X))
@end example

@subsubheading  Exceptional Situations::

If an attempt is made to bind a @i{symbol} that is defined as a @i{global variable},
an error of @i{type} @b{program-error} is signaled.

If @i{declaration} contains a @b{special} declaration 
that names one of the @i{symbols} being bound by @b{symbol-macrolet},
an error of @i{type} @b{program-error} is signaled.

@subsubheading  See Also::

@ref{with-slots}
, 
@ref{macroexpand}

@subsubheading  Notes::

The special form @b{symbol-macrolet} is the basic mechanism that is used to
implement @b{with-slots}.

If a @b{symbol-macrolet} @i{form} is a @i{top level form},
the @i{forms} are also processed as @i{top level forms}.
See @ref{File Compilation}.

@node *macroexpand-hook*, proclaim, symbol-macrolet, Evaluation and Compilation Dictionary
@subsection *macroexpand-hook*                                               [Variable]

@subsubheading  Value Type::

a @i{designator} for a @i{function} of three @i{arguments}:
  a @i{macro function},
  a @i{macro form},
  and an @i{environment} @i{object}.

@subsubheading  Initial Value::

a @i{designator} for a function that is equivalent to the @i{function} @b{funcall},
but that might have additional @i{implementation-dependent} side-effects.

@subsubheading  Description::

Used as the expansion interface hook by @b{macroexpand-1} to 
control the @i{macro expansion} process.
When a @i{macro form} is to be expanded,
this @i{function} is called with three arguments:
  the @i{macro function},
  the @i{macro form},
  and the @i{environment} in which the @i{macro form} is to be expanded.

The @i{environment} @i{object} has @i{dynamic extent};
the consequences are undefined if the @i{environment} @i{object} is 
referred to outside the @i{dynamic extent} of the macro expansion function.

@subsubheading  Examples::

@example
 (defun hook (expander form env)
    (format t "Now expanding: ~S~
    (funcall expander form env)) @result{}  HOOK 
 (defmacro machook (x y) `(/ (+ ,x ,y) 2)) @result{}  MACHOOK 
 (macroexpand '(machook 1 2)) @result{}  (/ (+ 1 2) 2), @i{true} 
 (let ((*macroexpand-hook* #'hook)) (macroexpand '(machook 1 2)))
@t{ |> } Now expanding (MACHOOK 1 2) 
@result{}  (/ (+ 1 2) 2), @i{true}
@end example

@subsubheading  See Also::

@ref{macroexpand}
, @b{macroexpand-1}, 
@ref{funcall}
, @ref{Evaluation}

@subsubheading  Notes::

The net effect of the chosen initial value is to just invoke the
@i{macro function}, giving it the @i{macro form} and
@i{environment} as its two arguments.

Users or user programs can @i{assign} this @i{variable} to
customize or trace the @i{macro expansion} mechanism.  Note, however,
that this @i{variable} is a global resource, potentially shared by
multiple @i{programs}; as such, if any two @i{programs} depend for
their correctness on the setting of this @i{variable}, those
@i{programs} may not be able to run in the same @i{Lisp image}.
For this reason, it is frequently best to confine its uses to debugging
situations.

Users who put their own function into @b{*macroexpand-hook*}
should consider saving the previous value of the hook, and calling that
value from their own.

@node proclaim, declaim, *macroexpand-hook*, Evaluation and Compilation Dictionary
@subsection proclaim                                                         [Function]

@code{proclaim}  @i{declaration-specifier} @result{}  @i{@i{implementation-dependent}}

@subsubheading  Arguments and Values::

@i{declaration-specifier}---a @i{declaration specifier}.

@subsubheading  Description::

@i{Establishes} the @i{declaration} specified by @i{declaration-specifier}
in the @i{global environment}.

Such a @i{declaration}, sometimes called a @i{global declaration} 
or a @i{proclamation}, is always in force unless locally @i{shadowed}.

@i{Names} of @i{variables} and @i{functions} within 
@i{declaration-specifier} refer to @i{dynamic variables} 
and global @i{function} definitions, respectively.

Figure 3--22 shows a list of @i{declaration identifiers} 
that can be used with @b{proclaim}.

@format
@group
@noindent
@w{  declaration  inline     optimize  type  }
@w{  ftype        notinline  special         }

@noindent
@w{  Figure 3--22: Global Declaration Specifiers}

@end group
@end format

An implementation is free to support other (@i{implementation-defined})
@i{declaration identifiers} as well.

@subsubheading  Examples::

@example
 (defun declare-variable-types-globally (type vars)
   (proclaim `(type ,type ,@@vars))
   type)

 ;; Once this form is executed, the dynamic variable *TOLERANCE*
 ;; must always contain a float.
 (declare-variable-types-globally 'float '(*tolerance*))
@result{}  FLOAT
@end example

@subsubheading  See Also::

@ref{declaim}
,
@b{declare},
@ref{Compilation}

@subsubheading  Notes::

Although the @i{execution} of a @b{proclaim} @i{form} 
has effects that might affect compilation, the compiler does not make
any attempt to recognize and specially process @b{proclaim} @i{forms}.
A @i{proclamation} such as the following, even if a @i{top level form},
does not have any effect until it is executed:

@example
(proclaim '(special *x*))
@end example

If compile time side effects are desired, @b{eval-when} may be useful.
For example:

@example
 (eval-when (:execute :compile-toplevel :load-toplevel)
   (proclaim '(special *x*)))
@end example

In most such cases, however, it is preferrable to use @b{declaim} for
this purpose.

Since @b{proclaim} @i{forms} are ordinary @i{function forms},
@i{macro forms} can expand into them.

@node declaim, declare, proclaim, Evaluation and Compilation Dictionary
@subsection declaim                                                             [Macro]

@code{declaim}  @i{@{@i{declaration-specifier}@}*} @result{}  @i{@i{implementation-dependent}}

@subsubheading  Arguments and Values::

@i{declaration-specifier}---a @i{declaration specifier}; not evaluated.

@subsubheading  Description::

Establishes the @i{declarations} specified by the @i{declaration-specifiers}.

If a use of this macro appears as a @i{top level form} in a @i{file} 
being processed by the @i{file compiler}, the proclamations are also made
at compile-time.  As with other defining macros, it is unspecified whether or
not the compile-time side-effects of a @b{declaim} persist after the
@i{file} has been @i{compiled}.

@subsubheading  Examples::

@subsubheading  See Also::

@b{declare},
@ref{proclaim}

@node declare, ignore, declaim, Evaluation and Compilation Dictionary
@subsection declare                                                            [Symbol]

@subsubheading  Syntax::

@code{declare}  @i{@{@i{declaration-specifier}@}*} 
@subsubheading  Arguments:: 

@i{declaration-specifier}---a @i{declaration specifier}; not evaluated.

@subsubheading  Description::

A @b{declare} @i{expression}, sometimes called a @i{declaration},
can occur only at the beginning of the bodies of certain @i{forms};
that is, it may be preceded only by other @b{declare} @i{expressions},
or by a @i{documentation string} if the context permits.

A @b{declare} @i{expression} can occur in a @i{lambda expression}
or in any of the @i{forms} listed in Figure 3--23.

@format
@group
@noindent
@w{  defgeneric                 do-external-symbols   prog                      }
@w{  define-compiler-macro      do-symbols            prog*                     }
@w{  define-method-combination  dolist                restart-case              }
@w{  define-setf-expander       dotimes               symbol-macrolet           }
@w{  defmacro                   flet                  with-accessors            }
@w{  defmethod                  handler-case          with-hash-table-iterator  }
@w{  defsetf                    labels                with-input-from-string    }
@w{  deftype                    let                   with-open-file            }
@w{  defun                      let*                  with-open-stream          }
@w{  destructuring-bind         locally               with-output-to-string     }
@w{  do                         macrolet              with-package-iterator     }
@w{  do*                        multiple-value-bind   with-slots                }
@w{  do-all-symbols             pprint-logical-block                            }

@noindent
@w{       Figure 3--23: Standardized Forms In Which Declarations Can Occur      }

@end group
@end format

A @b{declare} @i{expression} can only occur 
where specified by the syntax of these @i{forms}.
The consequences of attempting to evaluate a @b{declare} @i{expression} 
are undefined.  In situations where such @i{expressions} can appear, 
explicit checks are made for their presence and they are never actually evaluated;
it is for this reason that they
are called  ``@b{declare} @i{expressions}''
rather than ``@b{declare} @i{forms}.''

@i{Macro forms} cannot expand into declarations;
@b{declare} @i{expressions} must appear as actual @i{subexpressions} of
the @i{form} to which they refer.

Figure 3--24 shows a list of @i{declaration identifiers} 
that can be used with @b{declare}.

@format
@group
@noindent
@w{  dynamic-extent  ignore     optimize  }
@w{  ftype           inline     special   }
@w{  ignorable       notinline  type      }

@noindent
@w{  Figure 3--24: Local Declaration Specifiers}

@end group
@end format

An implementation is free to support other (@i{implementation-defined})
@i{declaration identifiers} as well.

@subsubheading  Examples::     

@example
 (defun nonsense (k x z)
   (foo z x)                     ;First call to foo
   (let ((j (foo k x))           ;Second call to foo
         (x (* k k)))
     (declare (inline foo) (special x z))
     (foo x j z)))               ;Third call to foo
@end example

In this example,
the @b{inline} declaration applies
only to the third call to @t{foo}, but not to the first or second ones.
The @b{special} declaration of @t{x} causes @b{let} 
to make a dynamic @i{binding} for @t{x}, and causes the reference to 
@t{x}
in the body of @b{let} to be a dynamic reference.
The reference to @t{x} in the second call to @t{foo} is a local reference
to the second parameter of @t{nonsense}.
The reference to @t{x} in the first call to @t{foo} is a local
reference, not a @b{special} one.  The @b{special} declaration of @t{z}
causes the reference to @t{z} in the 
third
call
to @t{foo} to be a dynamic reference; it does not
refer to the parameter to @t{nonsense} named @t{z}, because that
parameter @i{binding} has not been declared to be @b{special}.
(The @b{special} declaration of @t{z} does not appear in the body
of @b{defun},  but in an inner @i{form}, and therefore does not
affect the @i{binding} of the @i{parameter}.)

@subsubheading  Exceptional Situations::

The consequences  of trying to use a @b{declare} @i{expression} as 
a @i{form} to be @i{evaluated} are undefined.

[Editorial Note by KMP: Probably we need to say something here about ill-formed 
declare expressions.]

@subsubheading  See Also::

@ref{proclaim}
,
@ref{Type Specifiers},
@b{declaration},
@b{dynamic-extent},
@b{ftype},
@b{ignorable},
@b{ignore},
@b{inline},
@b{notinline},
@b{optimize},
@b{type}

@node ignore, dynamic-extent, declare, Evaluation and Compilation Dictionary
@subsection ignore, ignorable                                             [Declaration]

@subsubheading  Syntax::

@t{@r{(}ignore @{@i{var} | @r{(}@b{function} @i{fn}@r{)}@}*@r{)}}

@t{@r{(}ignorable @{@i{var} | @r{(}@b{function} @i{fn}@r{)}@}*@r{)}}

@subsubheading  Arguments::

@i{var}---a @i{variable} @i{name}.

@i{fn}---a @i{function} @i{name}.

@subsubheading  Valid Context::

@i{declaration}

@subsubheading  Binding Types Affected::

@i{variable}, @i{function}

@subsubheading  Description::

The @b{ignore} and @b{ignorable} declarations
refer to @i{for-value} @i{references} 
    to @i{variable} @i{bindings} for the @i{vars}
and to @i{function} @i{bindings} for the @i{fns}.

An @b{ignore} @i{declaration} specifies that
@i{for-value} @i{references} to the indicated @i{bindings}
will not
occur within the scope of the @i{declaration}.
Within the @i{scope} of such a @i{declaration},
it is desirable
for a compiler to issue a warning about 
the presence of
either a @i{for-value} @i{reference} to any @i{var} or @i{fn},
    or a @b{special} @i{declaration} for any @i{var}.

An @b{ignorable} @i{declaration} specifies that 
@i{for-value} @i{references} to the indicated @i{bindings}
might or might not
occur within the scope of the @i{declaration}.
Within the @i{scope} of such a @i{declaration},
it is not desirable
for a compiler to issue a warning about
the presence or absence of
either a @i{for-value} @i{reference} to any @i{var} or @i{fn},
    or a @b{special} @i{declaration} for any @i{var}.

When not within the @i{scope} 
of a @b{ignore} or @b{ignorable} @i{declaration},
it is desirable
for a compiler to issue a warning about
any @i{var} for which there is 
neither a @i{for-value} @i{reference} 
    nor a @b{special} @i{declaration},
or about
any @i{fn} for which there is 
     no @i{for-value} @i{reference}.

Any warning about a ``used'' or ``unused'' @i{binding} must be of @i{type} @b{style-warning},
and may not affect program semantics.

The @i{stream variables} established by 
     @b{with-open-file},
     @b{with-open-stream},
     @b{with-input-from-string},
 and @b{with-output-to-string},
and all @i{iteration variables} are, by definition, always ``used''.
Using @t{(declare (ignore @i{v}))}, 
for such a @i{variable} @i{v} has unspecified consequences.

@subsubheading  See Also::

@b{declare}

@node dynamic-extent, type, ignore, Evaluation and Compilation Dictionary
@subsection dynamic-extent                                                [Declaration]

@subsubheading  Syntax::

@t{(dynamic-extent [[@{@i{var}@}* |
		               @r{(}@b{function} @i{fn}@r{)}@r{*}]])}

@subsubheading  Arguments::

@i{var}---a @i{variable} @i{name}.

@i{fn}---a @i{function} @i{name}.

@subsubheading  Valid Context::

@i{declaration}

@subsubheading  Binding Types Affected::

@i{variable}, @i{function}

@subsubheading  Description::

In some containing @i{form}, @i{F}, this declaration
asserts for each @i{var_i} (which need not be bound by @i{F}),
and for each @i{value} @i{v_@{ij@}} that @i{var_i} takes on,
and for each @i{object} @i{x_@{ijk@}} that 
is
an @i{otherwise inaccessible part} of @i{v_@{ij@}} at any time when
@i{v_@{ij@}}
becomes the value of @i{var_i},
that just after the execution of @i{F} terminates, 
@i{x_@{ijk@}} is either @i{inaccessible}
(if @i{F} established a @i{binding} for @i{var_i})
or still an @i{otherwise inaccessible part} of the current value of 
@i{var_i} (if @i{F} did not establish a @i{binding} 
for @i{var_i}).

The same relation holds for each @i{fn_i}, 
except that the @i{bindings} are in the @i{function} @i{namespace}.

The compiler is permitted to use
this information in any way that is appropriate to the @i{implementation}
and that does not conflict with the semantics of @r{Common Lisp}.

@b{dynamic-extent} declarations can be @i{free declarations}
or @i{bound declarations}.

The @i{vars} and @i{fns} named in a @b{dynamic-extent} 
declaration must not refer to @i{symbol macro} or @i{macro} bindings.

@subsubheading  Examples::

Since stack allocation of the initial value entails knowing at the
@i{object}'s creation time that the @i{object} can be 
@i{stack-allocated},  it is not generally useful to make a 
@b{dynamic-extent} @i{declaration} for @i{variables}
which have no lexically apparent initial value. 
For example, it is probably useful to write:

@example
 (defun f ()
   (let ((x (list 1 2 3)))
     (declare (dynamic-extent x))
         ...))
@end example

This would permit those compilers that wish to do so to @i{stack allocate}
the list held by the local variable @t{x}.  It is permissible,
but in practice probably not as useful, to write:

@example
 (defun g (x) (declare (dynamic-extent x)) ...)
 (defun f () (g (list 1 2 3)))
@end example

Most compilers would probably not @i{stack allocate} the @i{argument}
to @t{g} in @t{f} because it would be a modularity violation for the compiler
to assume facts about @t{g} from within @t{f}.   Only an implementation that 
was willing to be responsible for recompiling @t{f} if the definition of @t{g} 
changed incompatibly could legitimately @i{stack allocate} the @i{list} 
argument to @t{g} in @t{f}.

Here is another example:

@example
 (declaim (inline g))
 (defun g (x) (declare (dynamic-extent x)) ...)
 (defun f () (g (list 1 2 3)))

 (defun f ()
   (flet ((g (x) (declare (dynamic-extent x)) ...))
     (g (list 1 2 3))))

@end example

In the previous example, some compilers might determine that optimization was 
possible and others might not.

A variant of this is the so-called ``stack allocated rest list''
that can be achieved (in implementations supporting the optimization) by:

@example
 (defun f (&rest x)
   (declare (dynamic-extent x))
   ...)
@end example

Note that although the initial value of @t{x} is not explicit, the @t{f}
function is responsible for assembling the list @t{x} from the passed arguments,
so the @t{f} function can be optimized by the compiler to construct a 
@i{stack-allocated} list instead of a heap-allocated list in implementations
that support such.

In the following example,

@example
 (let ((x (list 'a1 'b1 'c1))
       (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))
   (declare (dynamic-extent x y))
   ...)
@end example

The @i{otherwise inaccessible parts} of @t{x} are three 
@i{conses},  and the @i{otherwise inaccessible parts}
of @t{y} are three other @i{conses}.  
None of the symbols @t{a1},  @t{b1},  @t{c1},  @t{a2},
@t{b2},  @t{c2},  or @b{nil} is an
@i{otherwise inaccessible part} of @t{x} or @t{y} because each
is @i{interned} and hence @i{accessible} by the @i{package}
(or @i{packages}) in which it is @i{interned}.
However, if a freshly allocated @i{uninterned} @i{symbol} had
been used, it would have been an @i{otherwise inaccessible part} of
the @i{list} which contained it.

@example
;; In this example, the implementation is permitted to @i{stack allocate}
;; the list that is bound to X.
 (let ((x (list 1 2 3)))
   (declare (dynamic-extent x))
   (print x)
   :done)
@t{ |> } (1 2 3)
@result{}  :DONE

;; In this example, the list to be bound to L can be @i{stack-allocated}.
 (defun zap (x y z)
   (do ((l (list x y z) (cdr l)))
       ((null l))
     (declare (dynamic-extent l))
     (prin1 (car l)))) @result{}  ZAP
 (zap 1 2 3)
@t{ |> } 123
@result{}  NIL

;; Some implementations might open-code LIST-ALL-PACKAGES in a way
;; that permits using @i{stack allocation} of the list to be bound to L.
 (do ((l (list-all-packages) (cdr l)))
     ((null l))
   (declare (dynamic-extent l))
   (let ((name (package-name (car l))))
     (when (string-search "COMMON-LISP" name) (print name))))
@t{ |> } "COMMON-LISP"
@t{ |> } "COMMON-LISP-USER"
@result{}  NIL

;; Some implementations might have the ability to @i{stack allocate} 
;; rest lists.  A declaration such as the following should be a cue
;; to such implementations that stack-allocation of the rest list
;; would be desirable.
 (defun add (&rest x)
   (declare (dynamic-extent x))
   (apply #'+ x)) @result{}  ADD
 (add 1 2 3) @result{}  6

 (defun zap (n m)
   ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).
   ;; It may be slow, but with a good compiler at least it
   ;; doesn't waste much heap storage.  :-@}
   (let ((a (make-array n)))
     (declare (dynamic-extent a))
     (dotimes (i n) 
       (declare (dynamic-extent i))
       (setf (aref a i) (random (+ i 1))))
     (aref a m))) @result{}  ZAP
 (< (zap 5 3) 3) @result{}  @i{true}
@end example

The following are in error, since the value of @t{x} is used outside of its
@i{extent}:

@example
 (length (list (let ((x (list 1 2 3)))  ; Invalid
                (declare (dynamic-extent x))
                x)))

 (progn (let ((x (list 1 2 3)))  ; Invalid
          (declare (dynamic-extent x))
          x)
        nil)
@end example

@subsubheading  See Also::

@b{declare}

@subsubheading  Notes::

The most common optimization is to @i{stack allocate} the 
initial value of the @i{objects} named by the @i{vars}. 

It is permissible for an implementation to simply ignore this declaration.

@node type, inline, dynamic-extent, Evaluation and Compilation Dictionary
@subsection type                                                          [Declaration]

@subsubheading  Syntax::

@t{(type @i{typespec} @{@i{var}@}*)}

@t{(@i{typespec} @{@i{var}@}*)}

@subsubheading  Arguments::

@i{typespec}---a @i{type specifier}.

@i{var}---a @i{variable} @i{name}.

@subsubheading  Valid Context::

@i{declaration} or @i{proclamation}

@subsubheading  Binding Types Affected::

@i{variable}

@subsubheading  Description::

Affects
only variable @i{bindings} and specifies that the
@i{vars} take on 
values only of the specified @i{typespec}.
In particular, values assigned to the variables by @b{setq},
as well as the initial values of the @i{vars} must be of
the specified @i{typespec}.
@b{type} declarations never apply to function @i{bindings} (see @b{ftype}).

A type declaration of a @i{symbol} 
defined by @b{symbol-macrolet} is equivalent
to wrapping a @b{the} 
expression around the expansion of that @i{symbol},

although the @i{symbol}'s @i{macro expansion} is not actually affected.

The meaning of a type declaration
  is equivalent to changing each reference to 
a variable (@i{var}) within the scope of the
  declaration to @t{(the @i{typespec} @i{var})},
changing each expression assigned to the
  variable (@i{new-value}) within the scope of the declaration to 
@t{(the @i{typespec} @i{new-value})},
  and executing 
@t{(the @i{typespec} @i{var})} at the moment the scope of the declaration
  is entered.

A @i{type} declaration is valid in all declarations. The interpretation
  of a type declaration is as follows:
@table @asis

@item 1.  
During the execution of any reference to the
  declared variable within the scope of the declaration, the consequences
are 
undefined
if
  the value of the declared variable is not of the declared @i{type}.

@item 2.  
During the execution of any 
@b{setq} of the declared variable within the scope
  of the declaration, the consequences are 
undefined
if the newly assigned value of the
  declared variable is not of the declared @i{type}. 

@item 3.  
At the moment the
  scope of the declaration is entered, the consequences are 
undefined
if the value of the
  declared variable is not of the declared @i{type}.
@end table

A @i{type} declaration affects only variable references within
its scope.

If nested @i{type} declarations refer to the same variable,
  then the value of the variable must be a member of the intersection of
  the declared @i{types}.

  If there is a local @t{type} declaration for a dynamic
  variable, and there is also a global @t{type} proclamation for that same
  variable, then the value of the variable within the scope of the local
  declaration must be a member of the intersection of the two declared
  @i{types}.

@b{type} declarations can  be @i{free declarations}
or @i{bound declarations}.

A @i{symbol} cannot be both the name of a @i{type} and the name of a
declaration.  Defining a @i{symbol} as the @i{name} of a @i{class},
@i{structure}, @i{condition}, or @i{type}, when the @i{symbol}
has been @i{declared} as a declaration name, or vice versa, signals an error.

Within the @i{lexical scope} of an @b{array} type declaration, 
all references to @i{array} @i{elements} are assumed to satisfy the
@i{expressed array element type} (as opposed to the @i{upgraded array element type}).
A compiler can treat
the code within the scope of the @b{array} type declaration as if each
@i{access} of an @i{array} @i{element} were surrounded by an appropriate 
@b{the} form.

@subsubheading  Examples::

@example
 (defun f (x y)
   (declare (type fixnum x y))
   (let ((z (+ x y)))
     (declare (type fixnum z))
     z)) @result{}  F
 (f 1 2) @result{}  3
 ;; The previous definition of F is equivalent to
 (defun f (x y)
   ;; This declaration is a shorthand form of the TYPE declaration
   (declare (fixnum x y))
   ;; To declare the type of a return value, it's not necessary to
   ;; create a named variable.  A THE special form can be used instead.
   (the fixnum (+ x y))) @result{}  F
 (f 1 2) @result{}  3
@end example

@example
 (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))
 (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))

 (defun frob (an-array)
   (declare (type (array (signed-byte 5) 1) an-array))
   (setf (aref an-array 1) 31)
   (setf (aref an-array 2) 127)
   (setf (aref an-array 3) (* 2 (aref an-array 3)))
   (let ((foo 0))
     (declare (type (signed-byte 5) foo))
     (setf foo (aref an-array 0))))

 (frob *one-array*)
 (frob *another-array*)
@end example

The above definition of @t{frob} is equivalent to:

@example
 (defun frob (an-array)
   (setf (the (signed-byte 5) (aref an-array 1)) 31)
   (setf (the (signed-byte 5) (aref an-array 2)) 127)
   (setf (the (signed-byte 5) (aref an-array 3))
         (* 2 (the (signed-byte 5) (aref an-array 3))))
   (let ((foo 0))
     (declare (type (signed-byte 5) foo))
     (setf foo (the (signed-byte 5) (aref an-array 0)))))
@end example

Given an implementation in which 
@i{fixnums} are 29 bits but @b{fixnum} @i{arrays} 
are upgraded to signed 32-bit @i{arrays},
the following 
could be compiled with all @i{fixnum} arithmetic:

@example
 (defun bump-counters (counters)
   (declare (type (array fixnum *) bump-counters))
   (dotimes (i (length counters))
     (incf (aref counters i))))
@end example

@subsubheading  See Also::

@b{declare},
@ref{declaim}
,
@ref{proclaim}

@subsubheading  Notes::

@t{(@i{typespec} @{@i{var}@}*)} 
is an abbreviation for @t{(type @i{typespec} @{@i{var}@}*)}.

A @b{type} declaration for the arguments to a function does not
necessarily imply anything about the type of the result.  The following
function is not permitted to be compiled using @i{implementation-dependent}
@i{fixnum}-only arithmetic:

@example
 (defun f (x y) (declare (fixnum x y)) (+ x y))
@end example

To see why, consider @t{(f most-positive-fixnum 1)}.
Common Lisp defines that @t{F} must return a @i{bignum} here, rather
than signal an error or produce a mathematically incorrect result.
If you have special knowledge such ``@i{fixnum} overflow'' cases will
not come up, you can declare the result value to be in the @i{fixnum}
range, enabling some compilers to use more efficient arithmetic:

@example
 (defun f (x y)
   (declare (fixnum x y))
   (the fixnum (+ x y)))
@end example

Note, however, that in the three-argument case, because of the possibility
of an implicit intermediate value growing too large, the following will not
cause @i{implementation-dependent} @i{fixnum}-only arithmetic to be used:

@example
 (defun f (x y)
   (declare (fixnum x y z))
   (the fixnum (+ x y z)))
@end example

To see why, consider @t{(f most-positive-fixnum 1 -1).}
Although the arguments and the result are all @i{fixnums}, an intermediate
value is not a @i{fixnum}.  If it is important that 
@i{implementation-dependent} @i{fixnum}-only arithmetic be selected
in @i{implementations} that provide it, 
consider writing something like this instead:

@example
 (defun f (x y)
   (declare (fixnum x y z))
   (the fixnum (+ (the fixnum (+ x y)) z)))
@end example

@node inline, ftype, type, Evaluation and Compilation Dictionary
@subsection inline, notinline                                             [Declaration]

@subsubheading  Syntax::

@t{(inline @{@i{function-name}@}*)}

@t{(notinline @{@i{function-name}@}*)}

@subsubheading  Arguments::

@i{function-name}---a @i{function name}.

@subsubheading  Valid Context::

@i{declaration} or @i{proclamation}

@subsubheading  Binding Types Affected::

@i{function}

@subsubheading  Description::

@b{inline} specifies that
it is desirable for the compiler to produce inline calls
to the @i{functions} named by @i{function-names}; 
that is, the code for a specified @i{function-name}

should be integrated into the calling routine, appearing ``in line''
in place of a procedure call.  
A compiler is free to ignore this declaration.
@b{inline} declarations never apply to variable @i{bindings}. 

If one of the @i{functions} mentioned has a lexically apparent local definition
(as made by @b{flet} or @b{labels}), then the declaration
applies to that local definition and not to the global function definition.

While no @i{conforming implementation} is required to perform inline expansion
of user-defined functions, those @i{implementations} that do attempt
to recognize the following paradigm:

To define a @i{function} @t{f} that is not @b{inline} by default
but for which @t{(declare (inline f))} will make @i{f} be locally inlined,
the proper definition sequence is:

@example
 (declaim (inline f))
 (defun f ...)
 (declaim (notinline f))
@end example

The @b{inline} proclamation preceding the @b{defun} @i{form}
ensures that the @i{compiler} has the opportunity save the information
necessary for inline expansion, and the @b{notinline} proclamation 
following the @b{defun} @i{form} prevents @t{f} from being expanded
inline everywhere.  

@b{notinline} specifies that it is

undesirable to compile the @i{functions}
named by @i{function-names} in-line.
A compiler is not free to ignore this declaration;
calls to the specified functions must be implemented as out-of-line subroutine calls.

If one of the @i{functions}
mentioned has a lexically apparent local definition
(as made by @b{flet} or @b{labels}), then the declaration
applies to that local definition and not to the global function definition.

In the presence of a @i{compiler macro} definition for 
@i{function-name}, a @b{notinline} declaration prevents that

@i{compiler macro} from being used.

An @b{inline} declaration may be used to encourage use of 
@i{compiler macro} definitions.  @b{inline} and @b{notinline}
declarations otherwise have no effect when the lexically visible definition
of @i{function-name} is a @i{macro} definition.

@b{inline} and @b{notinline} declarations can be @i{free declarations} or
@i{bound declarations}.                  
@b{inline} and @b{notinline} declarations of functions that
appear before the body of a 
      @b{flet}
 or  @b{labels}

@i{form} that defines that function are @i{bound declarations}.  
Such declarations in other contexts are @i{free declarations}.

@subsubheading  Examples::

@example
 ;; The globally defined function DISPATCH should be open-coded,
 ;; if the implementation supports inlining, unless a NOTINLINE 
 ;; declaration overrides this effect.
 (declaim (inline dispatch))
 (defun dispatch (x) (funcall (get (car x) 'dispatch) x))
 ;; Here is an example where inlining would be encouraged.
 (defun top-level-1 () (dispatch (read-command)))
 ;; Here is an example where inlining would be prohibited.
 (defun top-level-2 ()
   (declare (notinline dispatch))
   (dispatch (read-command)))
 ;; Here is an example where inlining would be prohibited.
 (declaim (notinline dispatch))
 (defun top-level-3 () (dispatch (read-command)))
 ;; Here is an example where inlining would be encouraged.
 (defun top-level-4 () 
   (declare (inline dispatch))
   (dispatch (read-command)))
@end example

@subsubheading  See Also::

@b{declare},
@ref{declaim}
,
@ref{proclaim}

@node ftype, declaration, inline, Evaluation and Compilation Dictionary
@subsection ftype                                                         [Declaration]

@subsubheading  Syntax::

@t{(ftype @i{type} @{@i{function-name}@}*)}

@subsubheading  Arguments::

@i{function-name}---a @i{function name}.

@i{type}---a @i{type specifier}.

@subsubheading  Valid Context::

@i{declaration} or @i{proclamation}

@subsubheading  Binding Types Affected::

@i{function}

@subsubheading  Description::

Specifies that the @i{functions} named by @i{function-names} are of
the functional type @i{type}.
For example:

@example
 (declare (ftype (function (integer list) t) ith)
          (ftype (function (number) float) sine cosine))
@end example

If one of the @i{functions} mentioned has a lexically apparent local definition
(as made by @b{flet} or @b{labels}), then the declaration
applies to that local definition and not to the global function definition.
@b{ftype} declarations never apply to variable @i{bindings} (see @t{type}). 

The lexically apparent bindings of @i{function-names} must not be
@i{macro} definitions.  (This is because @b{ftype} declares the
functional definition of each @i{function name} to be of a particular
subtype of @b{function}, and @i{macros} do not denote 
@i{functions}.)

@b{ftype} 

declarations
can be @i{free declarations} or @i{bound declarations}.
@b{ftype} declarations of functions that appear before the body of a 
   @b{flet}
or @b{labels}

@i{form} that defines that function are @i{bound declarations}.  
Such declarations in other contexts are @i{free declarations}.

@subsubheading  See Also::

@b{declare},
@ref{declaim}
,
@ref{proclaim}

@node declaration, optimize, ftype, Evaluation and Compilation Dictionary
@subsection declaration                                                   [Declaration]

@subsubheading  Syntax::

@t{(declaration @{@i{name}@}*)}

@subsubheading  Arguments::

@i{name}---a @i{symbol}.

@subsubheading  Valid Context::

@i{proclamation} only

@subsubheading  Description::

Advises the compiler that each @i{name} is a valid but potentially
non-standard declaration name.  The purpose of this is to tell one
compiler not to issue warnings for declarations meant for another 
compiler or other program processor.

@subsubheading  Examples::

@example
 (declaim (declaration author target-language target-machine))
 (declaim (target-language ada))
 (declaim (target-machine IBM-650))
 (defun strangep (x)
   (declare (author "Harry Tweeker"))
   (member x '(strange weird odd peculiar)))
@end example

@subsubheading  See Also::

@ref{declaim}
,
@ref{proclaim}

@node optimize, special, declaration, Evaluation and Compilation Dictionary
@subsection optimize                                                      [Declaration]

@subsubheading  Syntax::

@t{(optimize @{@i{quality} | (@i{quality} @i{value})@}*)}

@IRindex compilation-speed

@IRindex debug

@IRindex safety

@IRindex space

@IRindex speed

@subsubheading  Arguments::

@i{quality}---an @i{optimize quality}.

@i{value}---one of the @i{integers} @t{0}, @t{1}, @t{2}, or @t{3}.

@subsubheading  Valid Context::

@i{declaration} or @i{proclamation}

@subsubheading  Description::

Advises the compiler that each @i{quality} should be given attention
according to the specified corresponding @i{value}.
Each @i{quality} must be a @i{symbol} naming an @i{optimize quality}; 
the names and meanings of the standard @i{optimize qualities} are shown in 
Figure 3--25.

@format
@group
@noindent
@w{  Name               Meaning                            }
@w{  @b{compilation-speed}  speed of the compilation process   }
@w{  @b{debug}              ease of debugging                  }
@w{  @b{safety}             run-time error checking            }
@w{  @b{space}              both code size and run-time space  }
@w{  @b{speed}              speed of the object code           }

@noindent
@w{             Figure 3--25: Optimize qualities           }

@end group
@end format

There may be other, @i{implementation-defined} @i{optimize qualities}.

A @i{value} @t{0} means that the corresponding @i{quality} is totally
unimportant, and @t{3} that the @i{quality} is extremely important;
@t{1} and @t{2} are intermediate values, with @t{1} the 
neutral value.
@t{(@i{quality} 3)} can be abbreviated to @i{quality}.

Note that @i{code} which has the optimization @t{(safety 3)},
or just @b{safety},
is called @i{safe} @i{code}.

The consequences are unspecified if a @i{quality} appears more than once
with @i{different} @i{values}.

@subsubheading  Examples::

@example
 (defun often-used-subroutine (x y)
   (declare (optimize (safety 2)))
   (error-check x y)
   (hairy-setup x)
   (do ((i 0 (+ i 1))
        (z x (cdr z)))
       ((null z))
     ;; This inner loop really needs to burn.
     (declare (optimize speed))
     (declare (fixnum i))
     ))
@end example

@subsubheading  See Also::

@b{declare},
@ref{declaim}
,
@ref{proclaim}
,
@ref{Declaration Scope}

@subsubheading  Notes::

An @b{optimize} declaration never applies to either a @i{variable} or
a @i{function} @i{binding}.  An @b{optimize} declaration can only
be a @i{free declaration}.  For more information, see @ref{Declaration Scope}.

@node special, locally, optimize, Evaluation and Compilation Dictionary
@subsection special                                                       [Declaration]

@subsubheading  Syntax::

@t{(special @{@i{var}@}*)}

@subsubheading  Arguments::

@i{var}---a @i{symbol}.

@subsubheading  Valid Context::

@i{declaration} or @i{proclamation}

@subsubheading  Binding Types Affected::

@i{variable}

@subsubheading  Description::

Specifies that all of
the @i{vars} named are dynamic.
This specifier affects variable @i{bindings} and 
affects references.
All variable @i{bindings} affected are made to be dynamic @i{bindings},
and affected variable references refer to the current dynamic 
@i{binding}.
For example:

@example
 (defun hack (thing *mod*)    ;The binding of the parameter
   (declare (special *mod*))  ; *mod* is visible to hack1,
   (hack1 (car thing)))       ; but not that of thing.
 (defun hack1 (arg)
   (declare (special *mod*))  ;Declare references to *mod*
                              ;within hack1 to be special.
   (if (atom arg) *mod*
       (cons (hack1 (car arg)) (hack1 (cdr arg)))))
@end example

A @b{special} declaration does not affect inner @i{bindings} 
of a @i{var}; the inner @i{bindings} implicitly shadow
a @b{special} declaration and must be explicitly re-declared to
be @b{special}.
@b{special} declarations never apply to function @i{bindings}.

@b{special} declarations can be either @i{bound declarations},
affecting both a binding and references, or @i{free declarations},
affecting only references, depending on whether the declaration is 
attached to a variable binding.

When used in a @i{proclamation}, a @b{special} 
@i{declaration specifier}
applies to all @i{bindings} as well as to all references of the
mentioned variables.  For example, after

@example
 (declaim (special x))
@end example

then in a function definition such as

@example
 (defun example (x) ...)
@end example

the parameter @t{x} is bound as a dynamic variable
rather than as a lexical variable.  

@subsubheading  Examples::

@example
(defun declare-eg (y)                 ;this y is special
 (declare (special y))
 (let ((y t))                         ;this y is lexical
      (list y
            (locally (declare (special y)) y)))) ;this y refers to the
                                                 ;special binding of y
@result{}  DECLARE-EG 
 (declare-eg nil) @result{}  (T NIL) 
@end example

@example
(setf (symbol-value 'x) 6)
(defun foo (x)                         ;a lexical binding of x
  (print x)
  (let ((x (1+ x)))                    ;a special binding of x
    (declare (special x))              ;and a lexical reference
    (bar))
  (1+ x))
(defun bar () 
  (print (locally (declare (special x))
           x)))
(foo 10) 
@t{ |> } 10
@t{ |> } 11
@result{}  11
@end example

@example
(setf (symbol-value 'x) 6)
(defun bar (x y)            ;[1] 1st occurrence of x
  (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence
        (x y))              ;[3] 3rd occurrence of x
    (declare (special x))
    (list old-x x)))
(bar 'first 'second) @result{}  (FIRST SECOND)
@end example

@example
 (defun few (x &optional (y *foo*))
   (declare (special *foo*))
   ...)
@end example

The reference to @t{*foo*}
in the first line of this example is not @b{special}
even though there is a @b{special} declaration in the second line.

@example
 (declaim (special prosp)) @result{}  @i{implementation-dependent}
 (setq prosp 1 reg 1) @result{}  1
 (let ((prosp 2) (reg 2))         ;the binding of prosp is special
    (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,
    (list prosp reg))             ;whereas the variable reg is lexical
@result{}  (3 2)
 (list prosp reg) @result{}  (1 3)

 (declaim (special x))          ;x is always special.
 (defun example (x y)                                 
   (declare (special y))
   (let ((y 3) (x (* x 2)))
     (print (+ y (locally (declare (special y)) y)))
     (let ((y 4)) (declare (special y)) (foo x)))) @result{}  EXAMPLE
@end example

In the contorted code above, the outermost and innermost @i{bindings} of
@t{y} are dynamic,
but the middle
binding is lexical. The two arguments to @t{+} are different,
one being the value, which is @t{3}, of the lexical variable
@t{y}, and the other being the value of the dynamic variable named @t{y}
(a @i{binding} 
of which happens, coincidentally, to lexically surround it at
an outer level).  All the @i{bindings} 
of @t{x} and references to @t{x}
are dynamic, however, because of the proclamation that @t{x} is
always @b{special}.

@subsubheading  See Also::

@ref{defparameter}
,
@b{defvar}

@node locally, the, special, Evaluation and Compilation Dictionary
@subsection locally                                                  [Special Operator]

@code{locally}  @i{@{@i{declaration}@}* @{@i{form}@}*} @result{}  @i{@{@i{result}@}*}

@subsubheading  Arguments and Values::

@i{Declaration}---a @b{declare} @i{expression}; not evaluated.

@i{forms}---an @i{implicit progn}.

@i{results}---the @i{values} of the @i{forms}.

@subsubheading  Description::

Sequentially evaluates a body of @i{forms}
in a @i{lexical environment} where the given @i{declarations} have effect.

@subsubheading  Examples::

@example
 (defun sample-function (y)  ;this y is regarded as special
   (declare (special y))                                
   (let ((y t))              ;this y is regarded as lexical
     (list y
           (locally (declare (special y))
             ;; this next y is regarded as special
             y))))
@result{}  SAMPLE-FUNCTION
 (sample-function nil) @result{}  (T NIL) 
 (setq x '(1 2 3) y '(4 . 5)) @result{}  (4 . 5)

;;; The following declarations are not notably useful in specific.
;;; They just offer a sample of valid declaration syntax using LOCALLY.
 (locally (declare (inline floor) (notinline car cdr))
          (declare (optimize space))
    (floor (car x) (cdr y))) @result{}  0, 1
@end example

@example
;;; This example shows a definition of a function that has a particular set
;;; of OPTIMIZE settings made locally to that definition.
 (locally (declare (optimize (safety 3) (space 3) (speed 0)))
   (defun frob (w x y &optional (z (foo x y)))
     (mumble x y z w)))
@result{}  FROB

;;; This is like the previous example, except that the optimize settings
;;; remain in effect for subsequent definitions in the same compilation unit.
 (declaim (optimize (safety 3) (space 3) (speed 0)))
 (defun frob (w x y &optional (z (foo x y)))
   (mumble x y z w))
@result{}  FROB
@end example

@subsubheading  See Also::

@b{declare}

@subsubheading  Notes::

The @b{special} declaration may be used with @b{locally}
to affect references to, rather than @i{bindings} of, @i{variables}.

If a @b{locally} @i{form} is a @i{top level form}, the body @i{forms}
are also processed as @i{top level forms}.  See @ref{File Compilation}.

@node the, special-operator-p, locally, Evaluation and Compilation Dictionary
@subsection the                                                      [Special Operator]

@code{the}  @i{value-type form} @result{}  @i{@{@i{result}@}*}

@subsubheading  Arguments and Values::

@i{value-type}---a @i{type specifier}; not evaluated.

@i{form}---a @i{form}; evaluated.

@i{results}---the @i{values} resulting from the @i{evaluation} of @i{form}.
  These @i{values} must conform to the @i{type} supplied by @i{value-type};
  see below.

@subsubheading  Description::

@b{the} specifies that the @i{values}_@{1a@} returned by @i{form}
are of the @i{types} specified by @i{value-type}.
The consequences are undefined if any @i{result}
is not of the declared type.

It is permissible for @i{form} to @i{yield} a different number of @i{values} 
than are specified by @i{value-type}, provided that the values
for which @i{types} are declared are indeed of those @i{types}.
Missing values are treated as @b{nil} for the purposes of checking their @i{types}.

Regardless of number of @i{values} declared by @i{value-type},
the number of @i{values} returned by the @b{the} @i{special form} is the same as
the number of @i{values} returned by @i{form}. 

@subsubheading  Examples::

@example
 (the symbol (car (list (gensym)))) @result{}  #:G9876
 (the fixnum (+ 5 7)) @result{}  12
 (the (values) (truncate 3.2 2)) @result{}  1, 1.2
 (the integer (truncate 3.2 2)) @result{}  1, 1.2
 (the (values integer) (truncate 3.2 2)) @result{}  1, 1.2
 (the (values integer float) (truncate 3.2 2))   @result{}  1, 1.2
 (the (values integer float symbol) (truncate 3.2 2)) @result{}  1, 1.2
 (the (values integer float symbol t null list) 
      (truncate 3.2 2)) @result{}  1, 1.2
 (let ((i 100))
    (declare (fixnum i))
    (the fixnum (1+ i))) @result{}  101
 (let* ((x (list 'a 'b 'c))
        (y 5))
    (setf (the fixnum (car x)) y)
    x) @result{}  (5 B C)
@end example

@subsubheading  Exceptional Situations::

The consequences are undefined if
the @i{values} @i{yielded} by the @i{form} 
are not of the @i{type} specified by @i{value-type}.

@subsubheading  See Also::

@b{values}

@subsubheading  Notes::

The @b{values} @i{type specifier} can be used to indicate the types
of @i{multiple values}:

@example
 (the (values integer integer) (floor x y))
 (the (values string t)
      (gethash the-key the-string-table))
@end example

@b{setf} can be used with @b{the} type declarations.
In this case the declaration is transferred to the form that
specifies  the new value.  The resulting @b{setf} @i{form}
is then analyzed.

@node special-operator-p, constantp, the, Evaluation and Compilation Dictionary
@subsection special-operator-p                                               [Function]

@code{special-operator-p}  @i{symbol} @result{}  @i{generalized-boolean}

@subsubheading  Arguments and Values::

@i{symbol}---a @i{symbol}.

@i{generalized-boolean}---a @i{generalized boolean}.

@subsubheading  Description::

Returns @i{true} if @i{symbol} is a @i{special operator};
otherwise, returns @i{false}.

@subsubheading  Examples::

@example
 (special-operator-p 'if) @result{}  @i{true}
 (special-operator-p 'car) @result{}  @i{false}
 (special-operator-p 'one) @result{}  @i{false}
@end example

@subsubheading  Exceptional Situations::

Should signal @b{type-error} if its argument is not a @i{symbol}.

@subsubheading  Notes::

Historically, this function was called @t{special-form-p}.  The name was
finally declared a misnomer and changed, since it returned true for
@i{special operators}, not @i{special forms}.

@node constantp,  , special-operator-p, Evaluation and Compilation Dictionary
@subsection constantp                                                        [Function]

@code{constantp}  @i{form @r{&optional} environment} @result{}  @i{generalized-boolean}

@subsubheading  Arguments and Values::

@i{form}---a @i{form}.

@i{environment}---an @i{environment} @i{object}.
 The default is @b{nil}.

@i{generalized-boolean}---a @i{generalized boolean}.

@subsubheading  Description::

Returns @i{true} if @i{form} can be determined
by the @i{implementation} to be a @i{constant form} 
in the indicated @i{environment}; 
otherwise, it returns @i{false} indicating either 
    that the @i{form} is not a @i{constant form}
 or that it cannot be determined whether or not @i{form} is a @i{constant form}.

The following kinds of @i{forms} are considered @i{constant forms}:
@table @asis

@item @t{*}  
@i{Self-evaluating objects} 
  (such as @i{numbers}, 
           @i{characters},
       and the various kinds of @i{arrays})
  are always considered @i{constant forms} 
  and must be recognized as such by @b{constantp}.

@item @t{*}  
@i{Constant variables}, such as @i{keywords},
  symbols defined by @r{Common Lisp} as constant (such as @b{nil}, @b{t}, and @b{pi}),
  and symbols declared as constant by the user in the indicated @i{environment}
   using @b{defconstant}
  are always considered @i{constant forms}
  and must be recognized as such by @b{constantp}.

@item @t{*}  
@b{quote} @i{forms} are always considered @i{constant forms}
  and must be recognized as such by @b{constantp}.

@item @t{*}  
An @i{implementation} is permitted, but not required, to detect
  additional @i{constant forms}.  If it does, it is also permitted,
  but not required, to make use of information in the @i{environment}.
  Examples of @i{constant forms} for which @b{constantp} might
  or might not return @i{true} are:
    @t{(sqrt pi)},
    @t{(+ 3 2)},
    @t{(length '(a b c))},
  and
    @t{(let ((x 7)) (zerop x))}.
@end table

If an @i{implementation} chooses to make use of the @i{environment}
information, such actions as expanding @i{macros} or performing function
inlining are permitted to be used, but not required; 
however, expanding @i{compiler macros} is not permitted.

@subsubheading  Examples::

@example
 (constantp 1) @result{}  @i{true}
 (constantp 'temp) @result{}  @i{false}
 (constantp ''temp)) @result{}  @i{true}
 (defconstant this-is-a-constant 'never-changing) @result{}  THIS-IS-A-CONSTANT 
 (constantp 'this-is-a-constant) @result{}  @i{true}
 (constantp "temp") @result{}  @i{true}
 (setq a 6) @result{}  6 
 (constantp a) @result{}  @i{true}
 (constantp '(sin pi)) @result{}  @i{implementation-dependent}
 (constantp '(car '(x))) @result{}  @i{implementation-dependent}
 (constantp '(eql x x)) @result{}  @i{implementation-dependent}
 (constantp '(typep x 'nil)) @result{}  @i{implementation-dependent}
 (constantp '(typep x 't)) @result{}  @i{implementation-dependent}
 (constantp '(values this-is-a-constant)) @result{}  @i{implementation-dependent}
 (constantp '(values 'x 'y)) @result{}  @i{implementation-dependent}
 (constantp '(let ((a '(a b c))) (+ (length a) 6))) @result{}  @i{implementation-dependent}
@end example

@subsubheading  Affected By::

The state of the global environment (@i{e.g.}, which @i{symbols} have been
declared to be the @i{names} of @i{constant variables}).

@subsubheading  See Also::

@ref{defconstant}

@c end of including dict-eval-compile

@c %**end of chapter

