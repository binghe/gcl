<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Numbers (GCL SI Manual)</title>

<meta name="description" content="Numbers (GCL SI Manual)">
<meta name="keywords" content="Numbers (GCL SI Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="Function-and-Variable-Index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Sequences-and-Arrays-and-Hash-Tables.html" rel="next" title="Sequences and Arrays and Hash Tables">
<link href="index.html" rel="prev" title="Top">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Numbers"></span><div class="header">
<p>
Next: <a href="Sequences-and-Arrays-and-Hash-Tables.html" accesskey="n" rel="next">Sequences and Arrays and Hash Tables</a>, Previous: <a href="index.html" accesskey="p" rel="prev">Top</a>, Up: <a href="index.html" accesskey="u" rel="up">Top</a> &nbsp; [<a href="Function-and-Variable-Index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Numbers-1"></span><h2 class="chapter">1 Numbers</h2>


<dl>
<dt id="index-SIGNUM">Function: <strong>SIGNUM</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>If NUMBER is zero, returns NUMBER; else returns (/ NUMBER (ABS NUMBER)).
</p>

</dd></dl>

<dl>
<dt id="index-LOGNOT">Function: <strong>LOGNOT</strong> <em>(integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the bit-wise logical NOT of INTEGER.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dPOSITIVE_002dSHORT_002dFLOAT">Constant: <strong>MOST-POSITIVE-SHORT-FLOAT</strong></dt>
<dd><p>Package:LISP
The short-float closest in value to positive infinity.
</p>

</dd></dl>

<dl>
<dt id="index-INTEGER_002dDECODE_002dFLOAT">Function: <strong>INTEGER-DECODE-FLOAT</strong> <em>(float)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns, as three values, the integer interpretation of significand F,
the exponent E, and the sign S of the given float, so that
			 E
	FLOAT = S * F * B	where B = (FLOAT-RADIX FLOAT)
</p>
<p>F is a non-negative integer, E is an integer, and S is either 1 or -1.
</p>

</dd></dl>

<dl>
<dt id="index-MINUSP">Function: <strong>MINUSP</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if NUMBER &lt; 0; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-LOGORC1">Function: <strong>LOGORC1</strong> <em>(integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the logical OR of (LOGNOT INTEGER1) and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dNEGATIVE_002dSINGLE_002dFLOAT">Constant: <strong>MOST-NEGATIVE-SINGLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as MOST-NEGATIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dC1">Constant: <strong>BOOLE-C1</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return the complement of INTEGER1.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dPOSITIVE_002dSHORT_002dFLOAT">Constant: <strong>LEAST-POSITIVE-SHORT-FLOAT</strong></dt>
<dd><p>Package:LISP
The positive short-float closest in value to zero.
</p>

</dd></dl>

<dl>
<dt id="index-BIT_002dNAND">Function: <strong>BIT-NAND</strong> <em>(bit-array1 bit-array2 &amp;optional (result-bit-array nil))</em></dt>
<dd><p>Package:LISP
</p>
<p>Performs a bit-wise logical NAND  on the elements of BIT-ARRAY1 and
BIT-ARRAY2.
Puts the results into a new bit array if RESULT-BIT-ARRAY is NIL, into
BIT-ARRAY1 if RESULT-BIT-ARRAY is T, or into RESULT-BIT-ARRAY otherwise.
</p>
</dd></dl>

<dl>
<dt id="index-INT_002dCHAR">Function: <strong>INT-CHAR</strong> <em>(integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Performs the inverse of CHAR-INT.  Equivalent to CODE-CHAR in GCL.
</p>

</dd></dl>

<dl>
<dt id="index-CHAR_002dINT">Function: <strong>CHAR-INT</strong> <em>(char)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the font, bits, and code attributes as a single non-negative integer.
Equivalent to CHAR-CODE in GCL.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dNEGATIVE_002dSINGLE_002dFLOAT">Constant: <strong>LEAST-NEGATIVE-SINGLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as LEAST-NEGATIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-_002f_003d">Function: <strong>/=</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if no two of its arguments are numerically equal; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-LDB_002dTEST">Function: <strong>LDB-TEST</strong> <em>(bytespec integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if at least one of the bits in the specified bytes of INTEGER is 1;
NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-CHAR_002dCODE_002dLIMIT">Constant: <strong>CHAR-CODE-LIMIT</strong></dt>
<dd><p>Package:LISP
The upper exclusive bound on values produced by CHAR-CODE.
</p>

</dd></dl>

<dl>
<dt id="index-RATIONAL">Function: <strong>RATIONAL</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Converts NUMBER into rational accurately and returns it.
</p>

</dd></dl>

<dl>
<dt id="index-PI">Constant: <strong>PI</strong></dt>
<dd><p>Package:LISP
The floating-point number that is appropriately equal to the ratio of the
circumference of the circle to the diameter.
</p>

</dd></dl>

<dl>
<dt id="index-SIN">Function: <strong>SIN</strong> <em>(radians)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the sine of RADIANS.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dORC2">Constant: <strong>BOOLE-ORC2</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGORC2 of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-NUMERATOR">Function: <strong>NUMERATOR</strong> <em>(rational)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns as an integer the numerator of the given rational number.
</p>

</dd></dl>

<dl>
<dt id="index-MASK_002dFIELD">Function: <strong>MASK-FIELD</strong> <em>(bytespec integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Extracts the specified byte from INTEGER.
</p>

</dd></dl>

<dl>
<dt id="index-INCF">Special Form: <strong>INCF</strong></dt>
<dd><p>Package:LISP
</p>
<p>Syntax:
</p><div class="example">
<pre class="example">(incf place [delta])
</pre></div>

<p>Adds the number produced by DELTA (which defaults to 1) to the number
in PLACE.
</p>

</dd></dl>

<dl>
<dt id="index-SINH">Function: <strong>SINH</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the hyperbolic sine of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-PHASE">Function: <strong>PHASE</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the angle part of the polar representation of a complex number.
For non-complex numbers, this is 0.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE">Function: <strong>BOOLE</strong> <em>(op integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns an integer produced by performing the logical operation specified by
OP on the two integers.  OP must be the value of one of the following
constants:
	BOOLE-CLR	BOOLE-C1	BOOLE-XOR	BOOLE-ANDC1
	BOOLE-SET	BOOLE-C2	BOOLE-EQV	BOOLE-ANDC2
	BOOLE-1		BOOLE-AND	BOOLE-NAND	BOOLE-ORC1
	BOOLE-2		BOOLE-IOR	BOOLE-NOR	BOOLE-ORC2
See the variable docs of these constants for their operations.
</p>

</dd></dl>

<dl>
<dt id="index-SHORT_002dFLOAT_002dEPSILON">Constant: <strong>SHORT-FLOAT-EPSILON</strong></dt>
<dd><p>Package:LISP
The smallest positive short-float that satisfies
	(not (= (float 1 e) (+ (float 1 e) e))).
</p>

</dd></dl>

<dl>
<dt id="index-LOGORC2">Function: <strong>LOGORC2</strong> <em>(integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the logical OR of INTEGER1 and (LOGNOT INTEGER2).
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dC2">Constant: <strong>BOOLE-C2</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return the complement of INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-REALPART">Function: <strong>REALPART</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Extracts the real part of NUMBER.
</p>

</dd></dl>


<dl>
<dt id="index-BOOLE_002dCLR">Constant: <strong>BOOLE-CLR</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return 0.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dIOR">Constant: <strong>BOOLE-IOR</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGIOR of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-FTRUNCATE">Function: <strong>FTRUNCATE</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Values: (quotient remainder)
Same as TRUNCATE, but returns first value as a float.
</p>

</dd></dl>

<dl>
<dt id="index-EQL">Function: <strong>EQL</strong> <em>(x y)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if X and Y are EQ, or if they are numbers of the same type with
the same value, or if they are character objects that represent the same
character.  Returns NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-LOG">Function: <strong>LOG</strong> <em>(number &amp;optional base)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the logarithm of NUMBER in the base BASE.  BASE defaults to the base
of natural logarithms.
</p>

</dd></dl>

<dl>
<dt id="index-DOUBLE_002dFLOAT_002dNEGATIVE_002dEPSILON">Constant: <strong>DOUBLE-FLOAT-NEGATIVE-EPSILON</strong></dt>
<dd><p>Package:LISP
Same as LONG-FLOAT-NEGATIVE-EPSILON.
</p>

</dd></dl>

<dl>
<dt id="index-LOGIOR">Function: <strong>LOGIOR</strong> <em>(&amp;rest integers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the bit-wise INCLUSIVE OR of its arguments.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dNEGATIVE_002dDOUBLE_002dFLOAT">Constant: <strong>MOST-NEGATIVE-DOUBLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as MOST-NEGATIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-_002f">Function: <strong>/</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Divides the first NUMBER by each of the subsequent NUMBERS.
With one arg, returns the reciprocal of the number.
</p>

</dd></dl>

<dl>
<dt id="index-_002aRANDOM_002dSTATE_002a">Variable: <strong>*RANDOM-STATE*</strong></dt>
<dd><p>Package:LISP
The default random-state object used by RAMDOM.
</p>

</dd></dl>

<dl>
<dt id="index-1_002b">Function: <strong>1+</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns NUMBER + 1.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dNEGATIVE_002dDOUBLE_002dFLOAT">Constant: <strong>LEAST-NEGATIVE-DOUBLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as LEAST-NEGATIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-FCEILING">Function: <strong>FCEILING</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Same as CEILING, but returns a float as the first value.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dPOSITIVE_002dFIXNUM">Constant: <strong>MOST-POSITIVE-FIXNUM</strong></dt>
<dd><p>Package:LISP
The fixnum closest in value to positive infinity.
</p>

</dd></dl>

<dl>
<dt id="index-BIT_002dANDC1">Function: <strong>BIT-ANDC1</strong> <em>(bit-array1 bit-array2 &amp;optional (result-bit-array nil))</em></dt>
<dd><p>Package:LISP
</p>
<p>Performs a bit-wise logical ANDC1 on the elements of BIT-ARRAY1 and
BIT-ARRAY2.
Puts the results into a new bit array if RESULT-BIT-ARRAY is NIL, into
BIT-ARRAY1 if RESULT-BIT-ARRAY is T, or into RESULT-BIT-ARRAY otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-TAN">Function: <strong>TAN</strong> <em>(radians)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the tangent of RADIANS.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dNAND">Constant: <strong>BOOLE-NAND</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGNAND of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-TANH">Function: <strong>TANH</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the hyperbolic tangent of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-ASIN">Function: <strong>ASIN</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the arc sine of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-BYTE">Function: <strong>BYTE</strong> <em>(size position)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns a byte specifier.  In GCL, a byte specifier is represented by
a dotted pair (&lt;size&gt; . &lt;position&gt;).
</p>

</dd></dl>

<dl>
<dt id="index-ASINH">Function: <strong>ASINH</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the hyperbolic arc sine of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dPOSITIVE_002dLONG_002dFLOAT">Constant: <strong>MOST-POSITIVE-LONG-FLOAT</strong></dt>
<dd><p>Package:LISP
The long-float closest in value to positive infinity.
</p>

</dd></dl>

<dl>
<dt id="index-SHIFTF">Macro: <strong>SHIFTF</strong></dt>
<dd><p>Package:LISP
</p>
<p>Syntax:
</p><div class="example">
<pre class="example">(shiftf {place}+ newvalue)
</pre></div>

<p>Evaluates all PLACEs and NEWVALUE in turn, then assigns the value of each
form to the PLACE on its left.  Returns the original value of the leftmost
form.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dPOSITIVE_002dLONG_002dFLOAT">Constant: <strong>LEAST-POSITIVE-LONG-FLOAT</strong></dt>
<dd><p>Package:LISP
The positive long-float closest in value to zero.
</p>

</dd></dl>

<dl>
<dt id="index-DEPOSIT_002dFIELD">Function: <strong>DEPOSIT-FIELD</strong> <em>(newbyte bytespec integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns an integer computed by replacing the specified byte of INTEGER with
the specified byte of NEWBYTE.
</p>

</dd></dl>

<dl>
<dt id="index-BIT_002dAND">Function: <strong>BIT-AND</strong> <em>(bit-array1 bit-array2 &amp;optional (result-bit-array nil))</em></dt>
<dd><p>Package:LISP
</p>
<p>Performs a bit-wise logical AND on the elements of BIT-ARRAY1 and BIT-ARRAY2.
Puts the results into a new bit array if RESULT-BIT-ARRAY is NIL, into
BIT-ARRAY1 if RESULT-BIT-ARRAY is T, or into RESULT-BIT-ARRAY otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-LOGNAND">Function: <strong>LOGNAND</strong> <em>(integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the complement of the logical AND of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-BYTE_002dPOSITION">Function: <strong>BYTE-POSITION</strong> <em>(bytespec)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the position part (in GCL, the cdr part) of the byte specifier.
</p>

</dd></dl>

<dl>
<dt id="index-ROTATEF">Macro: <strong>ROTATEF</strong></dt>
<dd><p>Package:LISP
</p>
<p>Syntax:
</p><div class="example">
<pre class="example">(rotatef {place}*)
</pre></div>

<p>Evaluates PLACEs in turn, then assigns to each PLACE the value of the form to
its right.  The rightmost PLACE gets the value of the leftmost PLACE.
Returns NIL always.
</p>

</dd></dl>

<dl>
<dt id="index-BIT_002dANDC2">Function: <strong>BIT-ANDC2</strong> <em>(bit-array1 bit-array2 &amp;optional (result-bit-array nil))</em></dt>
<dd><p>Package:LISP
</p>
<p>Performs a bit-wise logical ANDC2 on the elements of BIT-ARRAY1 and
BIT-ARRAY2.
Puts the results into a new bit array if RESULT-BIT-ARRAY is NIL, into
BIT-ARRAY1 if RESULT-BIT-ARRAY is T, or into RESULT-BIT-ARRAY otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-TRUNCATE">Function: <strong>TRUNCATE</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Values: (quotient remainder)
Returns NUMBER/DIVISOR as an integer, rounded toward 0.  The second returned
value is the remainder.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dEQV">Constant: <strong>BOOLE-EQV</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGEQV of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dSET">Constant: <strong>BOOLE-SET</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return -1.
</p>

</dd></dl>

<dl>
<dt id="index-LDB">Function: <strong>LDB</strong> <em>(bytespec integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Extracts and right-justifies the specified byte of INTEGER, and returns the
result.
</p>

</dd></dl>

<dl>
<dt id="index-BYTE_002dSIZE">Function: <strong>BYTE-SIZE</strong> <em>(bytespec)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the size part (in GCL, the car part) of the byte specifier.
</p>

</dd></dl>

<dl>
<dt id="index-SHORT_002dFLOAT_002dNEGATIVE_002dEPSILON">Constant: <strong>SHORT-FLOAT-NEGATIVE-EPSILON</strong></dt>
<dd><p>Package:LISP
The smallest positive short-float that satisfies
	(not (= (float 1 e) (- (float 1 e) e))).
</p>

</dd></dl>

<dl>
<dt id="index-REM">Function: <strong>REM</strong> <em>(number divisor)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the second value of (TRUNCATE NUMBER DIVISOR).
</p>

</dd></dl>

<dl>
<dt id="index-MIN">Function: <strong>MIN</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the least of its arguments.
</p>

</dd></dl>

<dl>
<dt id="index-EXP">Function: <strong>EXP</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Calculates e raised to the power NUMBER, where e is the base of natural
logarithms.
</p>

</dd></dl>

<dl>
<dt id="index-DECODE_002dFLOAT">Function: <strong>DECODE-FLOAT</strong> <em>(float)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns, as three values, the significand F, the exponent E, and the sign S
of the given float, so that
			 E
	FLOAT = S * F * B	where B = (FLOAT-RADIX FLOAT)
</p>
<p>S and F are floating-point numbers of the same float format as FLOAT, and E
is an integer.
</p>


</dd></dl>

<dl>
<dt id="index-LONG_002dFLOAT_002dEPSILON">Constant: <strong>LONG-FLOAT-EPSILON</strong></dt>
<dd><p>Package:LISP
The smallest positive long-float that satisfies
	(not (= (float 1 e) (+ (float 1 e) e))).
</p>

</dd></dl>

<dl>
<dt id="index-FROUND">Function: <strong>FROUND</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Same as ROUND, but returns first value as a float.
</p>

</dd></dl>

<dl>
<dt id="index-LOGEQV">Function: <strong>LOGEQV</strong> <em>(&amp;rest integers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the bit-wise EQUIVALENCE of its arguments.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dNEGATIVE_002dSHORT_002dFLOAT">Constant: <strong>MOST-NEGATIVE-SHORT-FLOAT</strong></dt>
<dd><p>Package:LISP
The short-float closest in value to negative infinity.
</p>

</dd></dl>

<dl>
<dt id="index-BIT_002dNOR">Function: <strong>BIT-NOR</strong> <em>(bit-array1 bit-array2 &amp;optional (result-bit-array nil))</em></dt>
<dd><p>Package:LISP
</p>
<p>Performs a bit-wise logical NOR  on the elements of BIT-ARRAY1 and BIT-ARRAY2.
Puts the results into a new bit array if RESULT-BIT-ARRAY is NIL, into
BIT-ARRAY1 if RESULT-BIT-ARRAY is T, or into RESULT-BIT-ARRAY otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-CEILING">Function: <strong>CEILING</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the smallest integer not less than or NUMBER/DIVISOR.  Returns the
remainder as the second value.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dNEGATIVE_002dSHORT_002dFLOAT">Constant: <strong>LEAST-NEGATIVE-SHORT-FLOAT</strong></dt>
<dd><p>Package:LISP
The negative short-float closest in value to zero.
</p>

</dd></dl>

<dl>
<dt id="index-1_002d">Function: <strong>1-</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns NUMBER - 1.
</p>

</dd></dl>

<dl>
<dt id="index-_003c_003d">Function: <strong>&lt;=</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if arguments are in strictly non-decreasing order; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-IMAGPART">Function: <strong>IMAGPART</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Extracts the imaginary part of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-INTEGERP">Function: <strong>INTEGERP</strong> <em>(x)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if X is an integer (fixnum or bignum); NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-ASH">Function: <strong>ASH</strong> <em>(integer count)</em></dt>
<dd><p>Package:LISP
</p>
<p>Shifts INTEGER left by COUNT places.  Shifts right if COUNT is negative.
</p>

</dd></dl>

<dl>
<dt id="index-LCM">Function: <strong>LCM</strong> <em>(integer &amp;rest more-integers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the least common multiple of the arguments.
</p>

</dd></dl>

<dl>
<dt id="index-COS">Function: <strong>COS</strong> <em>(radians)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the cosine of RADIANS.
</p>

</dd></dl>

<dl>
<dt id="index-DECF">Special Form: <strong>DECF</strong></dt>
<dd><p>Package:LISP
</p>
<p>Syntax:
</p><div class="example">
<pre class="example">(decf place [delta])
</pre></div>
<p>Subtracts the number
produced by DELTA (which defaults to 1) from the number in
PLACE.
</p>

</dd></dl>

<dl>
<dt id="index-ATAN">Function: <strong>ATAN</strong> <em>(x &amp;optional (y 1))</em></dt>
<dd><p>Package:LISP
 Returns the arc tangent of
X/Y.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dANDC1">Constant: <strong>BOOLE-ANDC1</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGANDC1 of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-COSH">Function: <strong>COSH</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
 Returns the hyperbolic cosine of
NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-FLOAT_002dRADIX">Function: <strong>FLOAT-RADIX</strong> <em>(float)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the representation radix (or base) of the floating-point
number.
</p>

</dd></dl>

<dl>
<dt id="index-ATANH">Function: <strong>ATANH</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the hyperbolic arc tangent of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-EVENP">Function: <strong>EVENP</strong> <em>(integer)</em></dt>
<dd><p>Package:LISP
 Returns T
if INTEGER is even.  Returns NIL if INTEGER is odd.
</p>

</dd></dl>

<dl>
<dt id="index-ZEROP">Function: <strong>ZEROP</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
 Returns T if NUMBER = 0; NIL
otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-FLOATP">Function: <strong>FLOATP</strong> <em>(x)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if X is a floating-point number; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-SXHASH">Function: <strong>SXHASH</strong> <em>(object)</em></dt>
<dd><p>Package:LISP
</p>
<p>Computes a hash code for OBJECT and returns it as an integer.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002d1">Constant: <strong>BOOLE-1</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return INTEGER1.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dPOSITIVE_002dSINGLE_002dFLOAT">Constant: <strong>MOST-POSITIVE-SINGLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as MOST-POSITIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-LOGANDC1">Function: <strong>LOGANDC1</strong> <em>(integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the logical AND of (LOGNOT INTEGER1) and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dPOSITIVE_002dSINGLE_002dFLOAT">Constant: <strong>LEAST-POSITIVE-SINGLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as LEAST-POSITIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-COMPLEXP">Function: <strong>COMPLEXP</strong> <em>(x)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if X is a complex number; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dAND">Constant: <strong>BOOLE-AND</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGAND of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-MAX">Function: <strong>MAX</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the greatest of its arguments.
</p>

</dd></dl>

<dl>
<dt id="index-FLOAT_002dSIGN">Function: <strong>FLOAT-SIGN</strong> <em>(float1 &amp;optional (float2 (float 1 float1)))</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns a floating-point number with the same sign as FLOAT1 and with the
same absolute value as FLOAT2.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dANDC2">Constant: <strong>BOOLE-ANDC2</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGANDC2 of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-DENOMINATOR">Function: <strong>DENOMINATOR</strong> <em>(rational)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the denominator of RATIONAL as an integer.
</p>

</dd></dl>

<dl>
<dt id="index-FLOAT">Function: <strong>FLOAT</strong> <em>(number &amp;optional other)</em></dt>
<dd><p>Package:LISP
</p>
<p>Converts a non-complex number to a floating-point number.  If NUMBER is
already a float, FLOAT simply returns NUMBER.  Otherwise, the format of
the returned float depends on OTHER;  If OTHER is not provided, FLOAT returns
a SINGLE-FLOAT.  If OTHER is provided, the result is in the same float format
as OTHER&rsquo;s.
</p>

</dd></dl>

<dl>
<dt id="index-ROUND">Function: <strong>ROUND</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Rounds NUMBER/DIVISOR to nearest integer.  The second returned value is the
remainder.
</p>

</dd></dl>

<dl>
<dt id="index-LOGAND">Function: <strong>LOGAND</strong> <em>(&amp;rest integers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the bit-wise AND of its arguments.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002d2">Constant: <strong>BOOLE-2</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-_002a">Function: <strong>*</strong> <em>(&amp;rest numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the product of its arguments.  With no args, returns 1.
</p>

</dd></dl>

<dl>
<dt id="index-_003c">Function: <strong>&lt;</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if its arguments are in strictly increasing order; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-COMPLEX">Function: <strong>COMPLEX</strong> <em>(realpart &amp;optional (imagpart 0))</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns a complex number with the given real and imaginary parts.
</p>

</dd></dl>

<dl>
<dt id="index-SINGLE_002dFLOAT_002dEPSILON">Constant: <strong>SINGLE-FLOAT-EPSILON</strong></dt>
<dd><p>Package:LISP
Same as LONG-FLOAT-EPSILON.
</p>

</dd></dl>

<dl>
<dt id="index-LOGANDC2">Function: <strong>LOGANDC2</strong> <em>(integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the logical AND of INTEGER1 and (LOGNOT INTEGER2).
</p>

</dd></dl>

<dl>
<dt id="index-INTEGER_002dLENGTH">Function: <strong>INTEGER-LENGTH</strong> <em>(integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the number of significant bits in the absolute value of INTEGER.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dNEGATIVE_002dFIXNUM">Constant: <strong>MOST-NEGATIVE-FIXNUM</strong></dt>
<dd><p>Package:LISP
The fixnum closest in value to negative infinity.
</p>

</dd></dl>

<dl>
<dt id="index-LONG_002dFLOAT_002dNEGATIVE_002dEPSILON">Constant: <strong>LONG-FLOAT-NEGATIVE-EPSILON</strong></dt>
<dd><p>Package:LISP
The smallest positive long-float that satisfies
	(not (= (float 1 e) (- (float 1 e) e))).
</p>

</dd></dl>

<dl>
<dt id="index-_003e_003d">Function: <strong>&gt;=</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if arguments are in strictly non-increasing order; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dNOR">Constant: <strong>BOOLE-NOR</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGNOR of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-ACOS">Function: <strong>ACOS</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the arc cosine of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-MAKE_002dRANDOM_002dSTATE">Function: <strong>MAKE-RANDOM-STATE</strong> <em>(&amp;optional (state *random-state*))</em></dt>
<dd><p>Package:LISP
</p>
<p>Creates and returns a copy of the specified random state.  If STATE is NIL,
then the value of *RANDOM-STATE* is used.  If STATE is T, then returns a
random state object generated from the universal time.
</p>

</dd></dl>

<dl>
<dt id="index-EXPT">Function: <strong>EXPT</strong> <em>(base-number power-number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns BASE-NUMBER raised to the power POWER-NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-SQRT">Function: <strong>SQRT</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the principal square root of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-SCALE_002dFLOAT">Function: <strong>SCALE-FLOAT</strong> <em>(float integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns (* FLOAT (expt (float-radix FLOAT) INTEGER)).
</p>

</dd></dl>

<dl>
<dt id="index-ACOSH">Function: <strong>ACOSH</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the hyperbolic arc cosine of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dNEGATIVE_002dLONG_002dFLOAT">Constant: <strong>MOST-NEGATIVE-LONG-FLOAT</strong></dt>
<dd><p>Package:LISP
The long-float closest in value to negative infinity.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dNEGATIVE_002dLONG_002dFLOAT">Constant: <strong>LEAST-NEGATIVE-LONG-FLOAT</strong></dt>
<dd><p>Package:LISP
The negative long-float closest in value to zero.
</p>

</dd></dl>

<dl>
<dt id="index-FFLOOR">Function: <strong>FFLOOR</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Same as FLOOR, but returns a float as the first value.
</p>

</dd></dl>

<dl>
<dt id="index-LOGNOR">Function: <strong>LOGNOR</strong> <em>(integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the complement of the logical OR of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-PARSE_002dINTEGER">Function: <strong>PARSE-INTEGER</strong> <em>(string &amp;key (start 0) (end (length string)) (radix 10) (junk-allowed nil))</em></dt>
<dd><p>Package:LISP
</p>
<p>Parses STRING for an integer and returns it.
</p>

</dd></dl>

<dl>
<dt id="index-_002b">Function: <strong>+</strong> <em>(&amp;rest numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the sum of its arguments.  With no args, returns 0.
</p>

</dd></dl>

<dl>
<dt id="index-_003d">Function: <strong>=</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if all of its arguments are numerically equal; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-NUMBERP">Function: <strong>NUMBERP</strong> <em>(x)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if X is any kind of number; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-MOST_002dPOSITIVE_002dDOUBLE_002dFLOAT">Constant: <strong>MOST-POSITIVE-DOUBLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as MOST-POSITIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-LOGTEST">Function: <strong>LOGTEST</strong> <em>(integer1 integer2)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if LOGAND of INTEGER1 and INTEGER2 is not zero; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-RANDOM_002dSTATE_002dP">Function: <strong>RANDOM-STATE-P</strong> <em>(x)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if X is a random-state object; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-LEAST_002dPOSITIVE_002dDOUBLE_002dFLOAT">Constant: <strong>LEAST-POSITIVE-DOUBLE-FLOAT</strong></dt>
<dd><p>Package:LISP
Same as LEAST-POSITIVE-LONG-FLOAT.
</p>

</dd></dl>

<dl>
<dt id="index-FLOAT_002dPRECISION">Function: <strong>FLOAT-PRECISION</strong> <em>(float)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the number of significant radix-B digits used to represent the
significand F of the floating-point number, where B = (FLOAT-RADIX FLOAT).
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dXOR">Constant: <strong>BOOLE-XOR</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGXOR of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-DPB">Function: <strong>DPB</strong> <em>(newbyte bytespec integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns an integer computed by replacing the specified byte of INTEGER with
NEWBYTE.
</p>

</dd></dl>

<dl>
<dt id="index-ABS">Function: <strong>ABS</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the absolute value of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-CONJUGATE">Function: <strong>CONJUGATE</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the complex conjugate of NUMBER.
</p>

</dd></dl>

<dl>
<dt id="index-CIS">Function: <strong>CIS</strong> <em>(radians)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns e raised to i*RADIANS.
</p>

</dd></dl>

<dl>
<dt id="index-ODDP">Function: <strong>ODDP</strong> <em>(integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if INTEGER is odd; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-RATIONALIZE">Function: <strong>RATIONALIZE</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Converts NUMBER into rational approximately and returns it.
</p>

</dd></dl>

<dl>
<dt id="index-ISQRT">Function: <strong>ISQRT</strong> <em>(integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the greatest integer less than or equal to the square root of the
given non-negative integer.
</p>

</dd></dl>

<dl>
<dt id="index-LOGXOR">Function: <strong>LOGXOR</strong> <em>(&amp;rest integers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the bit-wise EXCLUSIVE OR of its arguments.
</p>

</dd></dl>

<dl>
<dt id="index-_003e">Function: <strong>&gt;</strong> <em>(number &amp;rest more-numbers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if its arguments are in strictly decreasing order; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-LOGBITP">Function: <strong>LOGBITP</strong> <em>(index integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if the INDEX-th bit of INTEGER is 1.
</p>

</dd></dl>

<dl>
<dt id="index-DOUBLE_002dFLOAT_002dEPSILON">Constant: <strong>DOUBLE-FLOAT-EPSILON</strong></dt>
<dd><p>Package:LISP
Same as LONG-FLOAT-EPSILON.
</p>

</dd></dl>

<dl>
<dt id="index-LOGCOUNT">Function: <strong>LOGCOUNT</strong> <em>(integer)</em></dt>
<dd><p>Package:LISP
</p>
<p>If INTEGER is negative, returns the number of 0 bits.  Otherwise, returns
the number of 1 bits.
</p>

</dd></dl>

<dl>
<dt id="index-GCD">Function: <strong>GCD</strong> <em>(&amp;rest integers)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the greatest common divisor of INTEGERs.
</p>

</dd></dl>

<dl>
<dt id="index-RATIONALP">Function: <strong>RATIONALP</strong> <em>(x)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if X is an integer or a ratio; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-MOD">Function: <strong>MOD</strong> <em>(number divisor)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the second result of (FLOOR NUMBER DIVISOR).
</p>

</dd></dl>

<dl>
<dt id="index-MODF">Function: <strong>MODF</strong> <em>(number)</em></dt>
<dd><p>Package:SYSTEM
</p>
<p>Returns the integer and fractional part of a floating point number mod 1.0.
</p>

</dd></dl>

<dl>
<dt id="index-BOOLE_002dORC1">Constant: <strong>BOOLE-ORC1</strong></dt>
<dd><p>Package:LISP
Makes BOOLE return LOGORC1 of INTEGER1 and INTEGER2.
</p>

</dd></dl>

<dl>
<dt id="index-SINGLE_002dFLOAT_002dNEGATIVE_002dEPSILON">Constant: <strong>SINGLE-FLOAT-NEGATIVE-EPSILON</strong></dt>
<dd><p>Package:LISP
Same as LONG-FLOAT-NEGATIVE-EPSILON.
</p>

</dd></dl>

<dl>
<dt id="index-FLOOR">Function: <strong>FLOOR</strong> <em>(number &amp;optional (divisor 1))</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the largest integer not larger than the NUMBER divided by DIVISOR.
The second returned value is (- NUMBER (* first-value DIVISOR)).
</p>

</dd></dl>

<dl>
<dt id="index-PLUSP">Function: <strong>PLUSP</strong> <em>(number)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns T if NUMBER &gt; 0; NIL otherwise.
</p>

</dd></dl>

<dl>
<dt id="index-FLOAT_002dDIGITS">Function: <strong>FLOAT-DIGITS</strong> <em>(float)</em></dt>
<dd><p>Package:LISP
</p>
<p>Returns the number of radix-B digits used to represent the significand F of
the floating-point number, where B = (FLOAT-RADIX FLOAT).
</p>

</dd></dl>

<dl>
<dt id="index-RANDOM">Function: <strong>RANDOM</strong> <em>(number &amp;optional (state *random-state*))</em></dt>
<dd><p>Package:LISP
</p>
<p>Generates a uniformly distributed pseudo-random number between zero
(inclusive) and NUMBER (exclusive), by using the random state object STATE.
</p>

</dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="Sequences-and-Arrays-and-Hash-Tables.html" accesskey="n" rel="next">Sequences and Arrays and Hash Tables</a>, Previous: <a href="index.html" accesskey="p" rel="prev">Top</a>, Up: <a href="index.html" accesskey="u" rel="up">Top</a> &nbsp; [<a href="Function-and-Variable-Index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
